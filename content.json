{"meta":{"title":"Rat-racer's Blog","subtitle":null,"description":"stay busy and happy","author":"Lintao Fang","url":"http://yoursite.com"},"pages":[{"title":"书单","date":"2017-10-26T12:51:13.000Z","updated":"2017-10-26T11:39:15.000Z","comments":false,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":""},{"title":"关于我","date":"2017-10-26T14:16:16.000Z","updated":"2017-10-26T14:16:16.000Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"完美主义者，生性懒惰，没什么好介绍的，就一学渣渣，GPA渣渣"},{"title":"资源","date":"2017-10-27T03:52:19.000Z","updated":"2017-10-27T03:52:19.000Z","comments":false,"path":"resources/index.html","permalink":"http://yoursite.com/resources/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-10-26T14:05:18.000Z","updated":"2017-10-26T11:39:15.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-10-26T12:53:55.000Z","updated":"2017-10-26T11:39:15.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2017-10-26T12:51:21.000Z","updated":"2017-10-26T11:39:15.000Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2017-10-26T14:05:25.000Z","updated":"2017-10-26T11:39:15.000Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""}],"posts":[{"title":"Git docs学习笔记","slug":"Git-docs学习笔记","date":"2017-10-30T14:41:50.000Z","updated":"2017-10-30T14:43:44.000Z","comments":true,"path":"2017/10/30/Git-docs学习笔记/","link":"","permalink":"http://yoursite.com/2017/10/30/Git-docs学习笔记/","excerpt":"1.1 起步-关于版本控制 什么是版本控制系统(version control system.VCS)? 版本控制是一种记录一个或者若干个文件内容的变化，以便将来查阅特定版本修改情况的系统。版本控制系统可以对任何类型的文件进行版本控制，但大多数情况下开发者是对源代码文件作版本控制。 有哪些类型的版本控制系统？ 本地版本控制系统","text":"1.1 起步-关于版本控制 什么是版本控制系统(version control system.VCS)? 版本控制是一种记录一个或者若干个文件内容的变化，以便将来查阅特定版本修改情况的系统。版本控制系统可以对任何类型的文件进行版本控制，但大多数情况下开发者是对源代码文件作版本控制。 有哪些类型的版本控制系统？ 本地版本控制系统 它的工作原理是在硬盘上保存补丁集，所谓补丁是指文件修订前后的变化；通过应用所有的补丁，可以重新计算出各个版本的内容。 集中式版本控制系统 本地版本控制系统只适用于单个开发者。 遇到需要多个开发者协同工作的时候，本地版本控制系统就没用了。于是集中式的版本控制系统（centralized version control system,CVCS）应运而生。这类系统，诸如CVS,Subveision,Perforce等，都有一个单一的几种管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连接到这一台服务器，取出最心底额文件或者提交更新，多年以来，这已经成为版本控制系统的标准做法。 这种做法带来了很多好好粗，特别是相对于老式的本地CVS来说。每个人都可以在一定程度智商看到项目中其他人在做什么。而管理员也可以轻松掌握每个开发者的权限，并且管理一个cvcs要远比在各个客户端上维护本地数据库来的轻松容易。 这种做法最显而易见的缺点是中央服务器的故障，如果宕机一小时，那么在这一小时内，谁都无法更新，也都无法协同工作。如果中心数据库磁盘发生损坏，又没有做恰当备份，毫无疑问，将丢失所有的数据-包括项目的真个变更历史，只剩下各自机器上保留的单独快照。本地版本控制也存在这样的问题，只要项目的历史记录都被保存在同一个位置，就会有丢失所有历史记录的风险。 分布式版本控制系统 于是分布式版本控制系统（distributed version control system，DVCS）面世了，在这类系统中，像Git,Mercurial,Bazar,darcs等，客户端并不只提取最新版本的文件快照，而是把整个代码仓库完整的镜像下来，这么一来，任何一处系统工作用的服务器发生故障，事后都可以 用任何一个镜像出来的本地仓库恢复，因为每一次克隆操作都是一次对代码仓库的完整备份。 1.2 起步-Git简史同生活中很多伟大的事物一样，Git诞生于一个极富纷争大举创新的时代。Linux内核开源项目有着为数众多的参与者，绝大多数Linux内核维护工作都花在提交补丁和保存归档的繁琐事务上（1991-2002年间）、到2002年，整个项目组开始启动一个专有的分布式版本控制系统Bitkeeper来管理和维护代码。到了2005年，开发bitkeeper的商业公司同Linux内核开源社区的合作关系结束，他们收回了Linux内核社区免费试用bitkeepr的权力，这就迫使Linux开源社区特别是Linux的缔造者linus torvalds基于bitkeeper是的经验与教训，开发出自己的版本控制系统，他们对新的系统制定了若干目标: 速度 简单的设计 对非线性开发模式的强力支持 完全分布式 有能力高效管理类似Linux内核一样的超大规模的项目 自诞生于2005年以来，Git日臻完善成熟，在高度易用的同时，仍然保留着初期设立的目标，它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性管理系统。 1.3 起步-Git基础 Git和其他版本控制系统的主要差别在于对待数据的方法。其他系统将他们保存的信息看作是一组基本文件和每个文件随时间逐步积累的差异。 而Git不按照以上方式对待或者保存数据，Git对待数据更像是一个快照流 近乎所有操作都可以本地执行 Git保证完整性 Git的所有数据在存储之前都计算校验和，然后以校验和来引用，这意味着不可以在Git不知情的情况下，更改任何文件或者目录内容，这个功能建构再给他底层，是构成Git哲学不可或缺的部分，若你在传送过程中，中丢失信息或损坏文件，Git就能发现。 Git用以计算校验和的机制叫做SHA-1散列（hash，哈希）。这是一个由四十个十六进制字符组成的字符串，基于Git文件的内容或者目录计算出来。SHA-1看起来是这样： 24b9da6552252987aa493b52f8696cd6d3b00373 Git中使用这种哈希值的情况很多，你将经常看到这种哈希值。实际上，Git数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。 Git一般只添加数据 你执行的Git操作 ，几乎只往Git数据库中添加数据。很难让Git执行任何不可逆操作，或者让他以任何方式清除数据。同别的vcs一样，未提交更新时有可能丢失或弄乱修改的内容，但是一旦你提交快照到Git中，就难以再丢失数据，特别是，你定期的推送数据库到其他的数据库的话。 这使得我们使用Git成为一个安心愉悦的过程，因为我们甚至可以尽情的做各种尝试，而没有把事情弄糟的风险。 三种状态 Git有三种状态，你的文件可以处于其中之一，已提交（commited),已修改（modified），和已暂存（staged)。 Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。 工作目录是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作`‘索引’’，不过一般说法还是叫暂存区域。 基本的 Git 工作流程如下： 在工作目录中修改文件。 *暂存文件，将文件的快照放入暂存区域。 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。 如果 Git 目录中保存着的特定版本文件，就属于已提交状态。 如果作了修改并已放入暂存区域，就属于已暂存状态。 如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。 在Git 基础一章，你会进一步了解这些状态的细节，并学会如何根据文件状态实施后续操作，以及怎样跳过暂存直接提交。 1.4 起步-命令行1.5 起步-安装Git1.6 初次运行Git前的配置git自带一个git config的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置： –system 此电脑–global 此用户–local 此仓库 /etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 –system 选项的 git config 时，它会从此文件读写配置变量。 ~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 可以传递 –global 选项让 Git 读写此文件。 当前使用仓库的 Git 目录中的 config 文件（就是 .git/config）：针对该仓库。 –local 每一个级别覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。 用户信息当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改： git config –global user.name “John Doe”git config –global user.email johndoe@example.com 再次强调，如果使用了 –global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 –global 选项的命令来配置。 文本编辑器既然用户信息已经设置完毕，你可以配置默认文本编辑器了，当 Git 需要你输入信息时会调用它。 如果未配置，Git 会使用操作系统默认的文本编辑器，通常是 Vim。 如果你想使用不同的文本编辑器，例如 Emacs，可以这样做： git config –global core.editor emacs 检查配置信息如果想要检查你的配置，可以使用 git config –list 命令来列出所有 Git 当时能找到的配置。 git config –listuser.name=John Doeuser.email=johndoe@example.comcolor.status=autocolor.branch=autocolor.interactive=autocolor.diff=auto 你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：/etc/gitconfig 与 ~/.gitconfig）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。 你可以通过输入 git config ： 来检查 Git 的某一项配置 git config user.nameJohn Doe 1.7 获取帮助三种方式： git help config git config –help man git-config q quit 1.8 总结2.1Git基础-获取Git仓库 在现有的目录中初始化仓库 git init 仅仅完成初始化的操作，项目的文件还没有被追踪。 如果是一个已经存在的非空文件夹中初始化Git仓库来进行版本控制的话，应该开始追踪(add）这些文件并提交（commit）。git initgit add *.cgit add LICENSEgit commit -m “initial project version” 克隆现有的仓库 git clone url 当前目录新建仓库名文件夹，初始化.git文件夹，从元车行仓库拉取下所有数据放入.git文件夹，然后从中读取最新版本的文件的拷贝。 也可以自己自定义本地仓库的名字：git clone url myrepository git支持多种数据传输协议，http://, git:// ssh传输协议 2.2 Git基础-记录每次更新到数据库untracked(已创建，未追踪）changes to be commited (已经暂存staged，未提交commited）Changes not staged for commit (未暂存not staged） Git add：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态 2.3Git基础-查看提交历史git log查看提交历史 2.4 Git基础 撤销操作git commit –amend 重新提交 覆盖上次提交信息 git reset HEAD file_name 撤销暂存 git checkout file_name 撤销修改 2.5Git基础-远程仓库的使用git remote git remote -v q 退出 git config –help git help config man git-config","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"docs学习笔记","slug":"docs学习笔记","date":"2017-10-30T14:41:50.000Z","updated":"2017-10-30T14:41:51.000Z","comments":true,"path":"2017/10/30/docs学习笔记/","link":"","permalink":"http://yoursite.com/2017/10/30/docs学习笔记/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"argparse库学习","slug":"argparse库学习","date":"2017-10-30T10:09:58.000Z","updated":"2017-10-30T10:10:54.000Z","comments":true,"path":"2017/10/30/argparse库学习/","link":"","permalink":"http://yoursite.com/2017/10/30/argparse库学习/","excerpt":"argparse库是Python的命令行解析模块。 使用步骤： 导入库 import argparse 创建解析对象parser parser=argparse.ArgumentParser() 加入参数 parser.add_argument() 进行解析 args=parser.parse_args()","text":"argparse库是Python的命令行解析模块。 使用步骤： 导入库 import argparse 创建解析对象parser parser=argparse.ArgumentParser() 加入参数 parser.add_argument() 进行解析 args=parser.parse_args() ArgumentParser() 参数prog,usage,description,epilog都是用来修改帮助（–help,-h)中输出的内容。 测试用例 -h 结果 参数parents表示继承关系，继承parents list中所有parent对象的所有的参数 parents[parent1 ,parent2,….] 其他的比较少用，具体意义及用法参见文档，就不赘述了。 add_argument() 可选参数，其他位置参数 nargs 参数数量 N，* ，+，？ action store(默认）,store_const,store_true,store_false, append,append_const,count,help,version) default 默认值 type string（默认）,file ,int ,float choices 可供选择值 required 是否必选 reference: python argparse docs python命令行解析库argparse python argparse用法总结","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"argparse","slug":"argparse","permalink":"http://yoursite.com/tags/argparse/"}]},{"title":"mac环境变量配置及其理解&软连接","slug":"mac环境变量配置及其理解-软连接","date":"2017-10-27T16:31:57.000Z","updated":"2017-10-27T16:35:05.000Z","comments":true,"path":"2017/10/28/mac环境变量配置及其理解-软连接/","link":"","permalink":"http://yoursite.com/2017/10/28/mac环境变量配置及其理解-软连接/","excerpt":"什么是环境变量所谓环境变量，通俗的理解就是命令的路径譬如我的mac里安装了jdk1.6,jdk1.8那么当我执行javac指令的时候，改使用哪一个版本呢？ 这个时候就可以通过设置环境变量来确定。","text":"什么是环境变量所谓环境变量，通俗的理解就是命令的路径譬如我的mac里安装了jdk1.6,jdk1.8那么当我执行javac指令的时候，改使用哪一个版本呢？ 这个时候就可以通过设置环境变量来确定。 export JDK1.7=/usr/apps/jdk1.7export JDK1.8=/usr/apps/jdk1.8export PATH=$JDK1.7/bin 通过这样，将jdk1.7加入环境变量，即指定我默认的jdk版本是1.6 对于其他的命令亦此。 环境变量的作用就是就是用户可以在操作系统的各个目录之下，都能访问到所需要的工具目录内的内容。 mac的环境变量 查看当前环境变量 echo $PATH 分为全局用户环境变量，以及单个用户环境变量。 全局用户环境变量在： /etc/bashrc /etc/profile 单个用户的环境变量在 ~/.bash_profile 一般在~/.bash_profile修改环境变量，不需要修改全局用户变量 注：全局环境变量只有root用户才有权限修改，对于普通用户是只读的，用户要sudo才可以修改。 sudo vim /etc/bashrc 修改环境变量 cd ~vim .bash_profileexport PATH=…..:$PATHsource .bash_profile 如果是修改或者是新增环境变量的值，要source一下才会生效。 什么是软连接？硬连接 硬链接 异名同体 软连接 快捷方式 reference: Linux软连接和硬链接 Mac 中环境变量的配置和理解","categories":[],"tags":[]},{"title":"MacDown的基本使用","slug":"MacDown的基本使用","date":"2017-10-27T05:09:45.000Z","updated":"2017-10-27T16:56:30.000Z","comments":true,"path":"2017/10/27/MacDown的基本使用/","link":"","permalink":"http://yoursite.com/2017/10/27/MacDown的基本使用/","excerpt":"最近一直在寻找Mac上的比较好用的markdown编辑器，由于mac平台上有太多MarkDown编辑器，Typora，Mou,Ulysses,iA Writer，等等，工具太多，不知道如何选择，我索性就都下载下来，一个个试用，最后感觉还是macdown我比较喜欢。Macdown的好处是，使用简单，它的界面分为两栏，左栏编辑，右栏实时预览，我觉得这样很好，比较适合我这样的Markdown新手。好吧，下面介绍一下什么是Macdown以及基本语法。","text":"最近一直在寻找Mac上的比较好用的markdown编辑器，由于mac平台上有太多MarkDown编辑器，Typora，Mou,Ulysses,iA Writer，等等，工具太多，不知道如何选择，我索性就都下载下来，一个个试用，最后感觉还是macdown我比较喜欢。Macdown的好处是，使用简单，它的界面分为两栏，左栏编辑，右栏实时预览，我觉得这样很好，比较适合我这样的Markdown新手。好吧，下面介绍一下什么是Macdown以及基本语法。 什么是Macdown?MacDown是一个开源的，MarkDown语法编辑器，用于macOS平台。类似于Mou; here is the download link. 如果你安装了homebrew的话，可以直接用brew安装:brew cask install macdown Macdown的基本语法同其他编辑器一样，语法无非是标题，链接，图片，代码块什么的。 换行 行末加两个空格，然后回车 强调 加黑 **要加黑的内容** eg:我变黑了 加黄 &lt;mark&gt;要加黄的内容&lt;/mark&gt; eg:我是黄的 删除线 &lt;del&gt;要删除的内容&lt;/del&gt; eg：别删我 上脚注 我在下面&lt;sup&gt;我在上面&lt;/sup&gt; 我在下面我在上面 标题 这个不多说了，#，##，，，######标题依次为一级，二级，，六级，字号依次减小 特别的，使用二级标题的时候，在标题下面后有一条水平线 加链接以及图片 直接加链接：&lt;url&gt;即可，即直接在链接两侧加上&lt; &gt; 给链接起名字 [name](url)即可， 在文章中添加很多链接会显得很凌乱，特别是当链接比较长的时候，这样的情况下，我们可以这样做。将定义统一放在文章末尾，文中进行引用即可。 定义：[name]:URL引用：[name] 引用图片方法和上面类似，图片可以在本地，也可以通过url 定义：[picture name]:URL or PATH引用：![picture name] 插入代码 行代码只需要在其两侧加 `符号即可。 include&lt;stdio.h&gt; 插入代码块可以通过，缩进4个空格，或者代码块两端加。注意：插入代码块之前要空一行 块引用 first second term eg: fisrtsecondthird term1 term2 水平线*三个星号 表格 name number laji 1512 name score —– —— flt 100 laji 0 name number laji 1512 name score flt 100 laji 0","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"},{"name":"macdown","slug":"macdown","permalink":"http://yoursite.com/tags/macdown/"}]},{"title":"ictclass 简介","slug":"ictclass-简介","date":"2017-10-27T05:00:44.000Z","updated":"2017-10-27T08:28:07.000Z","comments":true,"path":"2017/10/27/ictclass-简介/","link":"","permalink":"http://yoursite.com/2017/10/27/ictclass-简介/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"lucene简介","slug":"lucene简介","date":"2017-10-27T04:56:35.000Z","updated":"2017-10-27T04:56:35.000Z","comments":true,"path":"2017/10/27/lucene简介/","link":"","permalink":"http://yoursite.com/2017/10/27/lucene简介/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Mac docker安装","slug":"Mac-docker安装","date":"2017-10-26T15:51:09.000Z","updated":"2017-10-26T15:51:09.000Z","comments":true,"path":"2017/10/26/Mac-docker安装/","link":"","permalink":"http://yoursite.com/2017/10/26/Mac-docker安装/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"ifconfig命令学习笔记","slug":"ifconfig","date":"2017-10-26T15:33:02.000Z","updated":"2017-10-27T16:56:27.000Z","comments":true,"path":"2017/10/26/ifconfig/","link":"","permalink":"http://yoursite.com/2017/10/26/ifconfig/","excerpt":"ifconfig=interfaces config 命令格式： ifconfig [网络设备][参数] 功能 查看和配置网络设备，当网络环境发生改变的时候可以通过该命令对网络进行相应的配置。","text":"ifconfig=interfaces config 命令格式： ifconfig [网络设备][参数] 功能 查看和配置网络设备，当网络环境发生改变的时候可以通过该命令对网络进行相应的配置。 命令参数 up 启动相应的网络设备/网卡 down 关闭指定的网络设备/网卡 arp 设置指定网卡是都支持ARP协议 -promisc 设置是否支持网卡的promiscuous模式 -allmulti 设置是否支持多播模式，如果选择该参数，网卡将接受网络中所有的多播数据包 -a 显示全部接口信息 -s 显示摘要信息 add 给指定网卡配置ipv6地址 del 删除指定网卡的ipv6地址 mtu&lt;字节数&gt; 设置网卡的最大传输单元 netmask&lt;子网掩码&gt; 设置网卡的子网掩码 tunel 建立隧道 dsaddr 设定一个远端地址，建立点对点通信 -broadcst&lt;地址&gt; 为指定网卡设置广播协议 -pointtopoint&lt;地址&gt; 为网卡设置点对点通讯协议 multicast 为网卡设置组播标识 address 为网卡设置IPV4地址 使用实例 查看设备信息 第一行：连接类型：以太网 硬件地址即MAC地址：… 第二行：inet 地址表示网卡的IP地址：10.211.55.5广播地址：10.211.55.255子网掩码：255.255.255.0 第六行：网卡的状态 UP:网卡处于开启状态 RUNNING：网卡的网线被插上 MULTICAST：允许组播 MTU=1500：最大传输单元1500字节 关闭开启网卡 sudo ifconfig eth1 down sudo ifconfig eth1 down 删除/添加ipv6地址 sudo ifconfig eth1 del/add ipv6-addr before after 修改MAC地址 sudo ifconfig eth1 hw ether MAC_ADDR 修改IP地址 sudo ifconfig eth1 IP_ADDR netmask ADDR broadcasr ADDR 其他操作 关闭或启动arp协议 ifconfig eth1 arpifconfig eth1 -arp 设置最大传输单元 ifconfig eth1 mtu 1500 Note:用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了参考：reference","categories":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"ifconfig","slug":"ifconfig","permalink":"http://yoursite.com/tags/ifconfig/"}]},{"title":"pl0笔记","slug":"pl0笔记","date":"2017-10-26T11:26:43.000Z","updated":"2017-10-27T04:59:12.000Z","comments":true,"path":"2017/10/26/pl0笔记/","link":"","permalink":"http://yoursite.com/2017/10/26/pl0笔记/","excerpt":"","text":"#pl0笔记 ##第一部分 pl0语言及其编译器 pl0语言介绍 pl0设计语言是一个比较简单的语言，它以赋值语句为基础，构造概念有顺序，条件，循环三种。pl0有子程序的概念，包括过程定义（可以嵌套）与调用且有局部变量说明。pl0唯一的数据类型是整型，可以用来说明该类型的变量和常量。当然pl0也具有通常的算术与逻辑运算。具体的pl0语法图如下所示。 pl0语言编译器 pl0编译器的基本工作流程如下图所示： 语法分析完成以下工作 1.跳过分隔符，即空格，回车，制表符 2.识别保留字，如begin，end，if ，while等 3.识别非保留字的 一般标志符，将次标志符赋值给全局量id，而全局量sym赋值为sym_identifier 4.识别数字序列，当前值赋值给全局量num,sym被赋值为sym_number 5.是被：=,&lt;=,&gt;=等特殊符号，全局量sym被赋值为sym_becomes,sym_leq,sym_gtr等。 相关函数有getsym(),getch(),其中getch()为获取单个字符函数，除此之外，它还完成: 识别且跳过行结束符 将输入源文件复写到输出文件 产生一份程序列表，输出相应行号或者指令计数器的值注意getch()识别一个字符后，文件指针指向下一个，而getc()不会。 语法分析 ###pl0的指令集 pl0的指令集包含7种指令，分别是：（1) LIT 将常数压栈（2) LOD 将变量值压栈（3) STO 将栈顶的值赋予某变量（4) CAL 过程调用（5) INT 在数据栈中分配存储空间（6) JMP,JPC 用于if,while语句的条件或者无条件控制转移指令（7) OPR 算术逻辑指令 指令格式 F,L,A的含义见下表 ![ins]","categories":[],"tags":[]}]}